<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Quantifying competition from inventory data • TreeCompR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Quantifying competition from inventory data">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">TreeCompR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/TreeCompR.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/ALS_inventory.html">ALS competition workflow</a></li>
    <li><a class="dropdown-item" href="../articles/competition-inventory.html">Quantifying competition from inventory data</a></li>
    <li><a class="dropdown-item" href="../articles/competition-pointcloud.html">Quantifying competition from point cloud data</a></li>
    <li><a class="dropdown-item" href="../articles/TLS_inventory.html">TLS competition workflow</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/juliarieder/TreeCompR/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Quantifying competition from inventory data</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/juliarieder/TreeCompR/blob/development/vignettes/competition-inventory.Rmd" class="external-link"><code>vignettes/competition-inventory.Rmd</code></a></small>
      <div class="d-none name"><code>competition-inventory.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="where-to-start">Where to start?<a class="anchor" aria-label="anchor" href="#where-to-start"></a>
</h2>
<p>With <code>TreeCompR</code>, it is possible to easily compute
size-distance-dependent competition indices based on inventory data.
This data can be collected in the field, or derived or modeled from 3D
point clouds. Depending on the input data, there are some necessary
pre-processing steps. We prepared two tutorials for processing laser
scanning data to obtain appropriate inventory data:</p>
<ul>
<li>From airborne laser scanning data to competition indices:
vignette(“ALS_inventory”): <a href="https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html">ALS
workflow</a>
</li>
<li>From ground-based laser scanning data (from MLS/TLS) to competition
indices: vignette(“TLS_inventory”): <a href="https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html">TLS
workflow</a>
</li>
</ul>
</div>
<div class="section level2">
<h2 id="preparations">Preparations<a class="anchor" aria-label="anchor" href="#preparations"></a>
</h2>
<p>To illustrate how <code>TreeCompR</code> can be included inside a
tidy workflow, we will make use of <a href="https://www.tidyverse.org/" class="external-link">tidyverse</a> functions throughout the
tutorial:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://juliarieder.github.io/TreeCompR/">TreeCompR</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org" class="external-link">tidyverse</a></span><span class="op">)</span></span></code></pre></div>
<p>To highlight where they are coming from, we will explicitly quote the
corresponding package for all functions used in the tutorial in the form
of <code><a href="https://purrr.tidyverse.org/reference/map.html" class="external-link">purrr::map()</a></code> for all functions besides the
<code>magrittr</code> pipe operator <code>%&gt;%</code>.</p>
</div>
<div class="section level2">
<h2 id="reading-in-forest-inventory-data-with-read_inv">Reading in forest inventory data with <code>read_inv()</code><a class="anchor" aria-label="anchor" href="#reading-in-forest-inventory-data-with-read_inv"></a>
</h2>
<p>To be able to be parsed as a <code>forest_inv</code> object,
inventory data must contain x and y coordinates of the individual trees
(in m), and to be able to compute competition they must contain at least
one size-related variable (e.g. height or diameter at breast height, or
others when working with custom indices).</p>
<p>To ensure that the inventory data is assigned correctly, inspect the
data thoroughly. Make sure to specify the units for dbh and height if
they differ from the default, which is cm for dbh and m for height. Tree
coordinates should <strong>always</strong> be specified in m. You can
either use <code><a href="../reference/read_inv.html">read_inv()</a></code> to validate data.frames or paths to
files with inventory data and convert them to an object type used by the
<code>TreeCompR</code> functions, or directly pass them to
<code><a href="../reference/compete_inv.html">compete_inv()</a></code>. The former is especially useful if you have
data with non-standard column names or data structures and want to have
full control over how they are parsed.</p>
<p>In a simple case, reading data with <code><a href="../reference/read_inv.html">read_inv()</a></code> with
standard settings (except for the metric tree diameters) looks like
this:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># read inventory with diameter units set to m</span></span>
<span><span class="va">inventory1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="st">"data/inventory1.csv"</span>,</span>
<span>  dbh_unit <span class="op">=</span> <span class="st">"m"</span><span class="op">)</span></span>
<span><span class="co">#&gt; The following columns were used to create the inventory dataset:</span></span>
<span><span class="co">#&gt; id     ---   ID</span></span>
<span><span class="co">#&gt; x      ---   X</span></span>
<span><span class="co">#&gt; y      ---   Y</span></span>
<span><span class="co">#&gt; dbh    ---   DBH</span></span></code></pre></div>
<p>If <code>verbose = TRUE</code> (the default), <code><a href="../reference/read_inv.html">read_inv()</a></code>
prints the names of the main inventory variables from the original data
set. This is helpful as a sanity check for the automatic column
detection.</p>
<p><code><a href="../reference/read_inv.html">read_inv()</a></code> does flexibly recognize a large number of
different spellings for the common inventory variables. If provided with
tabular data without explicitly specified variable names, the function
by default takes the columns named “X” and “Y” (or “x” and “y”) to be
the tree coordinates, and looks for columns named “height”, “height_m”
or “h” as well as “dbh”, “diameter”,“diam”, or “d” (in any
capitalization) as size-related variables. The tree ids are taken from
columns named “id”, “tree_id”, “treeID” or “tree.id” (in any
capitalization). All special characters besides “.” and “_” are stripped
from the column names before matching. If <code>verbose = TRUE</code>,
the function will inform you which columns were automatically identified
to avoid errors.</p>
<p>The resulting “forest_inv” object looks like this (basically a
modified data.table object that is printed with a header to easily
identify its class).</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">inventory1</span></span>
<span><span class="co">#&gt; ---------------------------------------  </span></span>
<span><span class="co">#&gt; 'forest_inv' class inventory dataset: </span></span>
<span><span class="co">#&gt; collection of 63 observations </span></span>
<span><span class="co">#&gt; ---------------------------------------</span></span>
<span><span class="co">#&gt;             id      x      y    dbh</span></span>
<span><span class="co">#&gt;         &lt;char&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt;</span></span>
<span><span class="co">#&gt;  1: FASY-43-01  1.009  0.908  5.047</span></span>
<span><span class="co">#&gt;  2: ACPL-43-02 11.683  1.449  6.786</span></span>
<span><span class="co">#&gt;  3: SOAU-43-03  6.770  2.155  4.675</span></span>
<span><span class="co">#&gt; ---                                </span></span>
<span><span class="co">#&gt; 61: FASY-43-61  9.390 28.357 40.283</span></span>
<span><span class="co">#&gt; 62: FASY-43-62  5.350 27.977 32.405</span></span>
<span><span class="co">#&gt; 63: FASY-43-63 16.750 28.615 43.841</span></span></code></pre></div>
<p>If you have variable names that cannot be automatically recognized,
you can specify them explicitly with the corresponding arguments either
as a character string of length 1 with the variable name or by directly
specifying the name without quotes. For example, assume you have a data
set with (metric) UTM coordinates from a Spanish source, i.e. with
“dap_cm” (diámetro en altura de pecho) instead of dbh and “altura”
instead of height:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># read inventory with custom (Spanish) column titles</span></span>
<span><span class="va">inventory2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="st">"data/inventory2.csv"</span>,  </span>
<span>  x <span class="op">=</span> <span class="va">utmx</span>,</span>
<span>  y <span class="op">=</span> <span class="va">utmy</span>,</span>
<span>  dbh <span class="op">=</span> <span class="va">dap_cm</span>,</span>
<span>  height <span class="op">=</span> <span class="va">altura</span>,</span>
<span>  dbh_unit <span class="op">=</span> <span class="st">"cm"</span>, </span>
<span>  height_unit <span class="op">=</span> <span class="st">"m"</span><span class="op">)</span></span>
<span><span class="co">#&gt; The following columns were used to create the inventory dataset:</span></span>
<span><span class="co">#&gt; id     ---   automatically generated</span></span>
<span><span class="co">#&gt; x      ---   utmx</span></span>
<span><span class="co">#&gt; y      ---   utmy</span></span>
<span><span class="co">#&gt; dbh    ---   dap_cm</span></span>
<span><span class="co">#&gt; height ---   altura</span></span></code></pre></div>
<p>Note that in this case, the function automatically generated an “id”
column with ascending numbers as there was nothing in the raw data that
could be automatically identified as an ID:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">inventory2</span></span>
<span><span class="co">#&gt; ---------------------------------------  </span></span>
<span><span class="co">#&gt; 'forest_inv' class inventory dataset: </span></span>
<span><span class="co">#&gt; collection of 88 observations </span></span>
<span><span class="co">#&gt; ---------------------------------------</span></span>
<span><span class="co">#&gt;         id      x      y    dbh height</span></span>
<span><span class="co">#&gt;     &lt;char&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt;</span></span>
<span><span class="co">#&gt;  1:      1  0.573  0.168  7.232 13.168</span></span>
<span><span class="co">#&gt;  2:      2 19.330  0.844  8.064 11.565</span></span>
<span><span class="co">#&gt;  3:      3 10.182  0.383 10.779 13.615</span></span>
<span><span class="co">#&gt; ---                                   </span></span>
<span><span class="co">#&gt; 86:     86 12.829 29.278  3.713  7.780</span></span>
<span><span class="co">#&gt; 87:     87 26.712 29.375  1.641  4.306</span></span>
<span><span class="co">#&gt; 88:     88  6.962 29.644  4.585 10.219</span></span></code></pre></div>
<p>Non-standard field separators etc. can be internally passed on to
<code><a href="https://rdatatable.gitlab.io/data.table/reference/fread.html" class="external-link">data.table::fread()</a></code> via the <code>...</code> arguments to
read more exotic formats such as the semicolon-separated “.csv” files
with commas as decimal separators used for example in Germany. If the
units are not specified explicitly, it is assumed that they are in the
standard units (m for height and cm for diameter) and do not need
conversion.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># read inventory with custom decimal and column separators</span></span>
<span><span class="va">inventory3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="st">"data/inventory3.csv"</span>, </span>
<span>  dec <span class="op">=</span> <span class="st">","</span>,</span>
<span>  sep <span class="op">=</span> <span class="st">";"</span>, </span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>In many cases, pre-processing of the inventories based on other
variables than coordinates and tree size is necessary. For that reason,
it is possible to read in any objects that inherit from class
<code>data.frame</code> (e.g., tibbles, data.tables or actual
data.frames) with <code><a href="../reference/read_inv.html">read_inv()</a></code>. In this example, a dataset is
first read in externally and filtered to get data of only one of the
plots in the dataset and then read in.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># read dataset outside read_inv and filter to a single plot</span></span>
<span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu">readr</span><span class="fu">::</span><span class="fu">read_csv</span><span class="op">(</span><span class="st">"data/inventory4.csv"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> </span>
<span>  <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html" class="external-link">filter</a></span><span class="op">(</span><span class="va">plot_id</span> <span class="op">==</span> <span class="st">"Plot 1"</span><span class="op">)</span></span>
<span><span class="va">dat</span></span>
<span><span class="co">#&gt; # A tibble: 131 × 7</span></span>
<span><span class="co">#&gt;    plot_id tree_id       x        y  diam     h canopy_area</span></span>
<span><span class="co">#&gt;    &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;</span></span>
<span><span class="co">#&gt;  1 Plot 1    20492 563149. 5508576. 26.0  27.4        0.755</span></span>
<span><span class="co">#&gt;  2 Plot 1    20526 563176. 5508576. 28.2  27.5        0.814</span></span>
<span><span class="co">#&gt;  3 Plot 1    20559 563144. 5508577. 50.1  33.7        0.451</span></span>
<span><span class="co">#&gt;  4 Plot 1    20563 563172. 5508576. 24.6  21.1        0.447</span></span>
<span><span class="co">#&gt;  5 Plot 1    20593 563141. 5508577. 43.4  30.1        2.04 </span></span>
<span><span class="co">#&gt;  6 Plot 1    20594 563146. 5508577. 38.9  35.5        2.56 </span></span>
<span><span class="co">#&gt;  7 Plot 1    20630 563160. 5508577. 33.2  30.3        1.22 </span></span>
<span><span class="co">#&gt;  8 Plot 1    20731 563166. 5508578.  7.28  9.15       0.680</span></span>
<span><span class="co">#&gt;  9 Plot 1    20769 563133. 5508579.  4.27  6.62       0.568</span></span>
<span><span class="co">#&gt; 10 Plot 1    20771 563145. 5508579. 42.7  31.8        0.946</span></span>
<span><span class="co">#&gt; # ℹ 121 more rows</span></span>
<span><span class="co">#&gt; # ℹ Use `print(n = ...)` to see more rows</span></span>
<span>  </span>
<span><span class="co"># use read_inv to convert to a forest_inv object that works with TreeCompR functions</span></span>
<span><span class="va">inventory4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="va">dat</span>,</span>
<span>  dbh <span class="op">=</span> <span class="va">diam</span>,</span>
<span>  dbh_unit <span class="op">=</span> <span class="st">"cm"</span>, </span>
<span>  height_unit <span class="op">=</span> <span class="st">"m"</span>, </span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">inventory4</span></span>
<span><span class="co">#&gt; ---------------------------------------  </span></span>
<span><span class="co">#&gt; 'forest_inv' class inventory dataset: </span></span>
<span><span class="co">#&gt; collection of 131 observations </span></span>
<span><span class="co">#&gt; ---------------------------------------</span></span>
<span><span class="co">#&gt;          id        x       y    dbh height</span></span>
<span><span class="co">#&gt;      &lt;char&gt;    &lt;num&gt;   &lt;num&gt;  &lt;num&gt;  &lt;num&gt;</span></span>
<span><span class="co">#&gt;   1:  20492 563148.6 5508576 25.966 27.448</span></span>
<span><span class="co">#&gt;   2:  20526 563175.9 5508576 28.151 27.527</span></span>
<span><span class="co">#&gt;   3:  20559 563144.0 5508577 50.075 33.730</span></span>
<span><span class="co">#&gt;  ---                                      </span></span>
<span><span class="co">#&gt; 129:  24253 563163.7 5508624 35.541 28.049</span></span>
<span><span class="co">#&gt; 130:  24254 563172.3 5508623 46.562 32.352</span></span>
<span><span class="co">#&gt; 131:  24255 563176.8 5508625 59.293 32.698</span></span></code></pre></div>
<p>If there are additional columns that should be kept in the forest
inventory dataset (such as the canopy area in this case), it is possible
to specify <code>keep_rest = TRUE</code>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># read same inventory without dropping columns</span></span>
<span><span class="va">inventory4a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="va">dat</span>,</span>
<span>  dbh <span class="op">=</span> <span class="va">diam</span>,</span>
<span>  dbh_unit <span class="op">=</span> <span class="st">"cm"</span>, </span>
<span>  height_unit <span class="op">=</span> <span class="st">"m"</span>, </span>
<span>  keep_rest <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">inventory4a</span></span>
<span><span class="co">#&gt; ---------------------------------------  </span></span>
<span><span class="co">#&gt; 'forest_inv' class inventory dataset: </span></span>
<span><span class="co">#&gt; collection of 131 observations </span></span>
<span><span class="co">#&gt; ---------------------------------------</span></span>
<span><span class="co">#&gt;          id        x       y    dbh height plot_id canopy_area</span></span>
<span><span class="co">#&gt;      &lt;char&gt;    &lt;num&gt;   &lt;num&gt;  &lt;num&gt;  &lt;num&gt;  &lt;char&gt;       &lt;num&gt;</span></span>
<span><span class="co">#&gt;   1:  20492 563148.6 5508576 25.966 27.448  Plot 1       0.755</span></span>
<span><span class="co">#&gt;   2:  20526 563175.9 5508576 28.151 27.527  Plot 1       0.814</span></span>
<span><span class="co">#&gt;   3:  20559 563144.0 5508577 50.075 33.730  Plot 1       0.451</span></span>
<span><span class="co">#&gt;  ---                                                          </span></span>
<span><span class="co">#&gt; 129:  24253 563163.7 5508624 35.541 28.049  Plot 1       0.602</span></span>
<span><span class="co">#&gt; 130:  24254 563172.3 5508623 46.562 32.352  Plot 1       7.765</span></span>
<span><span class="co">#&gt; 131:  24255 563176.8 5508625 59.293 32.698  Plot 1       0.634</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="designating-target-trees-with-define_target">Designating target trees with <code>define_target()</code><a class="anchor" aria-label="anchor" href="#designating-target-trees-with-define_target"></a>
</h2>
<p>To select target trees for computing competition indices, you can use
the function <code><a href="../reference/define_target.html">define_target()</a></code>.</p>
<p>There are many different ways of specifying target trees that are
described in the documentation of <code><a href="../reference/define_target.html">define_target()</a></code>. Briefly,
you can directly supply tree IDs as a character string, you can define
them based on logical vectors, you can supply another
<code>forest_inv</code> object created with <code>read_tree()</code>
that contains their coordinates, or finally with a character string
specifying a method to define the target trees (“buff_edge”,
“exclude_edge” and “all_trees”).</p>
<div class="section level3">
<h3 id="designating-target-trees-based-on-subsetting">Designating target trees based on subsetting<a class="anchor" aria-label="anchor" href="#designating-target-trees-based-on-subsetting"></a>
</h3>
<p>Defining targets with a vector of tree IDs could look like this,
assuming you want to compute competition indices for 3 adjacent
<em>Fagus sylvatica</em> trees and this is your naming scheme:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># set target trees based on character vector with tree ids</span></span>
<span><span class="va">targets1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_target.html">define_target</a></span><span class="op">(</span></span>
<span>  inv <span class="op">=</span> <span class="va">inventory1</span>, </span>
<span>  target_source <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"FASY-43-24"</span>, <span class="st">"FASY-43-27"</span>, <span class="st">"FASY-43-30"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">targets1</span></span>
<span><span class="co">#&gt; --------------------------------------------------------------- </span></span>
<span><span class="co">#&gt; 'target_inv' class inventory dataset with defined target trees: </span></span>
<span><span class="co">#&gt; collection of 63 observations containing 3 target trees. </span></span>
<span><span class="co">#&gt; Source of target trees: character vector </span></span>
<span><span class="co">#&gt; ---------------------------------------------------------------</span></span>
<span><span class="co">#&gt;             id      x      y    dbh target</span></span>
<span><span class="co">#&gt;         &lt;char&gt;  &lt;num&gt;  &lt;num&gt;  &lt;num&gt; &lt;lgcl&gt;</span></span>
<span><span class="co">#&gt;  1: FASY-43-01  1.009  0.908  5.047  FALSE</span></span>
<span><span class="co">#&gt;  2: ACPL-43-02 11.683  1.449  6.786  FALSE</span></span>
<span><span class="co">#&gt;  3: SOAU-43-03  6.770  2.155  4.675  FALSE</span></span>
<span><span class="co">#&gt; ---                                       </span></span>
<span><span class="co">#&gt; 61: FASY-43-61  9.390 28.357 40.283  FALSE</span></span>
<span><span class="co">#&gt; 62: FASY-43-62  5.350 27.977 32.405  FALSE</span></span>
<span><span class="co">#&gt; 63: FASY-43-63 16.750 28.615 43.841  FALSE</span></span></code></pre></div>
<p>Objects of class “target_inv” are “forest_inv” type forest inventory
datasets that have an additional target column with a logical “target”
vector that identifies the target trees.</p>
<p>To visually inspect the position of the designated target trees
relative to the other trees in the neighbourhood, you can use the
function <code><a href="../reference/plot_target.html">plot_target()</a></code>, which automatically displays the
relevant information depending on the <code>target_source</code> setting
for both <code>target_inv</code> datasets and the output of
<code><a href="../reference/compete_inv.html">compete_inv()</a></code> itself. Here is a plot of the target trees
with a buffer of 10 m which is fully surrounded by other trees, showing
that it is possible to calculate competition indices with a 10 m search
radius for the three targets:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">targets1</span>, radius <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<p><img src="../reference/figures/targets1.png" alt="plot_trees" width="600"></p>
<p>The purpose of this function is to provide a fast tool for visual
inspection rather than to create beautiful visual output. As all the
data for the plot are contained in the <code>target_inv</code> object,
more appealing (e.g., <a href="https://ggplot2.tidyverse.org/" class="external-link">ggplot2</a>-based) visualizations
are left as an exercise to the user.</p>
<p>You might also want to define target trees based on a logical
criterion, for instance for all trees whose ID contains “FASY”:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># set target trees based on logical vector</span></span>
<span><span class="va">targets2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_target.html">define_target</a></span><span class="op">(</span></span>
<span>  inv <span class="op">=</span> <span class="va">inventory1</span>, </span>
<span>  target_source <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">grepl</a></span><span class="op">(</span><span class="st">"FASY"</span>, <span class="va">inventory1</span><span class="op">$</span><span class="va">id</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="co"># visual inspection</span></span>
<span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">targets1</span>, radius <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<p><img src="../reference/figures/targets2.png" alt="plot_trees" width="600"></p>
<p>In this case, the plot of the target trees shows that many of the
target trees are situated on the plot border, which would result in edge
effects. In such cases, we strongly advice against computing indices for
these trees (see below). To avoid calculating competition indices in
situations where it is not appropriate, we recommend to make plotting
with <code><a href="../reference/plot_target.html">plot_target()</a></code> a standard step of your workflow.</p>
</div>
<div class="section level3">
<h3 id="designating-target-trees-based-on-coordinates-from-other-data-sources">Designating target trees based on coordinates from other data
sources<a class="anchor" aria-label="anchor" href="#designating-target-trees-based-on-coordinates-from-other-data-sources"></a>
</h3>
<p>In many cases you will have target tree coordinates that come from a
different data source and have a different accuracy than the inventory
data, for instance when you perform a ground-based study focusing on
single trees and wish to derive tree competition from ALS sources based
on the GPS coordinates from your trees. In these cases, you will have to
match the GPS coordinates against the tree coordinates derived from the
ALS source (see <a href="https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html">ALS
workflow</a> for details on how to derive inventory data from ALS
sources).</p>
<p>In these cases, it is possible to supply an inventory based on a
second set of coordinates as a <code>target_source</code> which is then
matched against the inventory data. IDs are then ignored (as they are
likely automatically generated anyway) and matching is based only on the
closest trees within a buffer of <code>tol</code> m (the default is
<code>tol = 1</code>: matching within 1 m). All further size-related
variables in the second set of coordinates are ignored as well to ensure
the competition indices are based on the same data source. Here, GPS
coordinates for 15 trees are read in and matched against the data in the
inventory.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># designate target trees based on GPS coordinates</span></span>
<span><span class="co"># read target tree positions</span></span>
<span><span class="op">(</span><span class="va">target_pos</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span></span>
<span>  <span class="st">"data/target_tree_gps.csv"</span>, x <span class="op">=</span> <span class="va">gps_x</span>, y <span class="op">=</span> <span class="va">gps_y</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; ---------------------------------------  </span></span>
<span><span class="co">#&gt; 'forest_inv' class inventory dataset: </span></span>
<span><span class="co">#&gt; collection of 15 observations </span></span>
<span><span class="co">#&gt; ---------------------------------------</span></span>
<span><span class="co">#&gt;          id        x       y</span></span>
<span><span class="co">#&gt;      &lt;char&gt;    &lt;num&gt;   &lt;num&gt;</span></span>
<span><span class="co">#&gt;  1: FASY-01 563157.6 5508615</span></span>
<span><span class="co">#&gt;  2: FASY-02 563141.8 5508602</span></span>
<span><span class="co">#&gt;  3: FASY-03 563147.0 5508610</span></span>
<span><span class="co">#&gt; ---                         </span></span>
<span><span class="co">#&gt; 13: FASY-13 563161.4 5508611</span></span>
<span><span class="co">#&gt; 14: FASY-14 563154.7 5508609</span></span>
<span><span class="co">#&gt; 15: FASY-15 563140.0 5508607</span></span>
<span></span>
<span><span class="co"># define target trees</span></span>
<span><span class="va">targets3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_target.html">define_target</a></span><span class="op">(</span></span>
<span>  inv <span class="op">=</span> <span class="va">inventory1</span>, </span>
<span>  target_source <span class="op">=</span> <span class="va">target_pos</span>,</span>
<span>  tol <span class="op">=</span> <span class="fl">1</span> <span class="co"># match within 1 m accuracy</span></span>
<span>  <span class="op">)</span></span>
<span><span class="co"># visual inspection</span></span>
<span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">targets3</span>, radius <span class="op">=</span> <span class="fl">8</span><span class="op">)</span></span></code></pre></div>
<p><img src="../reference/figures/targets3.png" alt="plot_trees" width="600"></p>
<p>For the intended 8 m search radius, these coordinates are
appropriate.</p>
<p>If no trees in the inventory are within the desired tolerance of one
or more of your target trees, or if several target trees are in within
the tolerance, you will receive a warning. If there is more than one
tree that is an equally good match for a target tree within 5 cm
difference, the function will fail with an error.</p>
</div>
<div class="section level3">
<h3 id="designating-target-trees-based-on-spatial-arrangement">Designating target trees based on spatial arrangement<a class="anchor" aria-label="anchor" href="#designating-target-trees-based-on-spatial-arrangement"></a>
</h3>
<p>In many cases, there will be no list of a priori specified target
trees, and the aim will be to calculate valid competition indices for as
many trees as possible. In these cases, we recommend to use
<code>target_source = "buff_edge"</code>. This automatically designates
all trees in the plot that are at least one search radius away from the
plot edge (roughly approximated by a concave hull) to avoid edge
effects. This is particularly important for TLS/MLS data and traditional
forest inventories, which, unlike ALS-derived datasets, tend to cover
relatively small forest plots rather than entire forests. Setting
<code>target_source = "exclude_edge"</code> only removes the trees on
the edge of the plot without checking how close the rest of the trees is
from the edge and is hence less restrictive but more prone to edge
effects than the previous option. If you use these spatially explicit
methods of defining target trees, make sure that your inventory only
contains data from one plot as currently grouping is not possible in
<code><a href="../reference/define_target.html">define_target()</a></code>. If you want to consider doing this for a
larger number of plots, consider e.g. mapping over the plots with
[purrr::map()] to compute the output step by step.</p>
<p>Here is an example of how to identify all potential target trees that
run in no risk of excluding potential edge trees when computing
competition indices for the same tree as in the previous example, again
with a search radius of 8 m:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># designate target trees with a 10 m buffer to the plot border</span></span>
<span><span class="va">targets4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_target.html">define_target</a></span><span class="op">(</span></span>
<span>  inv <span class="op">=</span> <span class="va">inventory4</span>, </span>
<span>  target_source <span class="op">=</span> <span class="st">"buff_edge"</span>, </span>
<span>  radius <span class="op">=</span> <span class="fl">8</span><span class="op">)</span></span>
<span><span class="co"># visual inspection</span></span>
<span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">targets4</span><span class="op">)</span></span></code></pre></div>
<p><img src="../reference/figures/targets4.png" alt="plot_trees" width="600"></p>
<p>In this case, the radius does not have to be specified in
<code><a href="../reference/plot_target.html">plot_target()</a></code> as the radius used for the buffer is stored
in the attributes of the “target_inv” object.</p>
<p>Doing the same with <code>target_source = "exclude_edge"</code>
results in the following:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># designate target trees by only excluding the plot border</span></span>
<span><span class="va">targets5</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_target.html">define_target</a></span><span class="op">(</span></span>
<span>  inv <span class="op">=</span> <span class="va">inventory4</span>, </span>
<span>  target_source <span class="op">=</span> <span class="st">"exclude_edge"</span>,</span>
<span>  radius <span class="op">=</span> <span class="fl">8</span><span class="op">)</span></span>
<span><span class="co"># visual inspection</span></span>
<span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">targets5</span><span class="op">)</span></span></code></pre></div>
<p><img src="../reference/figures/targets5.png" alt="plot_trees" width="600"></p>
<p>It can be seen that only the trees that are directly on the plot
border were removed. The radius in this case is again passed on to
<code><a href="../reference/plot_target.html">plot_target()</a></code>, but in this case only used to determine the
minimum possible distance between two edge trees for the concave hull
algorithm. This method of determining edge trees is considerably less
restrictive than “buff_edge”, and in this case resulted in a large
number of trees with buffers extending further than the plot. We
therefore recommend to be careful with this setting.</p>
<p>If a certain amount of overlap between the plot border and buffers of
individual trees is permitted it is usually better to use “buff_edge”
with a radius below the intended search radius as it maintains a
constant distance.</p>
</div>
<div class="section level3">
<h3 id="designating-all-trees-as-target-trees">Designating all trees as target trees<a class="anchor" aria-label="anchor" href="#designating-all-trees-as-target-trees"></a>
</h3>
<p>While it is possible to compute competition indices for all trees
(<code>target_source = "all_trees"</code>), this results in a warning
and should only be done if there are <strong>very good reasons</strong>
to assume that the edge trees in the data are actually situated at the
forest edge, as otherwise there will be <em>intense</em> edge effects:
for a tree on a straight plot edge, on average nearly half and for a
tree in an edge position in a rectangular plot 3/4 of the competitors
will be missing in the data! Therefore, this setting should only be used
for ALS derived data where it is clear that a whole forest is being used
as input.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># designate all trees as target trees</span></span>
<span><span class="va">targets6</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/define_target.html">define_target</a></span><span class="op">(</span></span>
<span>  inv <span class="op">=</span> <span class="va">inventory4</span>, </span>
<span>  target_source <span class="op">=</span> <span class="st">"all_trees"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning message:</span></span>
<span><span class="co">#&gt; In define_target(inv = inventory4, target_source = "all_trees") :</span></span>
<span><span class="co">#&gt;   Defining all trees as target trees is rarely a good idea. Unless your</span></span>
<span><span class="co">#&gt; forest inventory contains all trees in the forest, this will lead to strong</span></span>
<span><span class="co">#&gt; edge effects. Please make sure that this is really what you want to do.</span></span>
<span></span>
<span><span class="co"># visual inspection</span></span>
<span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">targets6</span>, radius <span class="op">=</span> <span class="fl">8</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning message:</span></span>
<span><span class="co">#&gt; In plot_target(targets6, radius = 8) :</span></span>
<span><span class="co">#&gt;   All trees in the dataset are defined as as target trees.</span></span></code></pre></div>
<p><img src="../reference/figures/targets6.png" alt="plot_trees" width="600"></p>
</div>
</div>
<div class="section level2">
<h2 id="computing-competition-indices-with-compete_inv">Computing competition indices with <code>compete_inv()</code><a class="anchor" aria-label="anchor" href="#computing-competition-indices-with-compete_inv"></a>
</h2>
<div class="section level3">
<h3 id="basic-usage">Basic usage<a class="anchor" aria-label="anchor" href="#basic-usage"></a>
</h3>
<p><code><a href="../reference/compete_inv.html">compete_inv()</a></code> is very flexible with its input, in
essence directly accepting everything that can also be loaded with
<code><a href="../reference/read_inv.html">read_inv()</a></code> and also passing additional settings for column
specifications etc. on to this function, which is then used to load the
data internally. In addition, all options for <code>target_source</code>
that can be set in <code><a href="../reference/define_target.html">define_target()</a></code> can be directly
specified in <code><a href="../reference/compete_inv.html">compete_inv()</a></code>. In consequence, in most use
cases this function will likely be called directly unless there are
reasons to perform the other steps explicitly, for instance, because the
data structure and formatting differ between the inventory and target
files and require different sets of custom column name settings, or
because an inspection of the target settings and spatial configuration
is desired <em>before</em> computing the results (which is certainly a
good idea for large datasets).</p>
<p>To identify the neighbour trees within the search radius of each
target tree, <code><a href="../reference/compete_inv.html">compete_inv()</a></code>uses the function
<code>knn()</code> from package <a href="https://github.com/jefferis/nabor" class="external-link">nabor</a> that is based on a
very efficient C++ implementation of the k-nearest neighbor algorithm
from <a href="https://github.com/norlab-ulaval/libnabo" class="external-link">libnabo</a>.
This makes it possible to deal with very large inventory datasets in a
relatively fast way as the pairwise distances of far-away trees are
never actually evaluated. In order to do this, it is necessary to
specify a maximum number of nearest neighbors to consider for each tree,
which has to be sufficiently larger than the maximum number of trees
expected in a search radius (<code>kmax</code>, by default 999). The
function then identifies which among the nearest neighbors are within
the search radius.</p>
<p>For most datasets, the choice of <code>kmax</code> will not play a
role as search radii large enough to contain that many trees rarely make
sense from a biological perspective, and because in many cases
performance differences between different values of <code>kmax</code>
will hardly be notable. However, for very large inventory datasets, as
can be expected when working with ALS data sources, The performance
difference compared to the regular pairwise-distance-based
implementations as e.g. <code><a href="https://r-spatial.github.io/sf/reference/geos_binary_pred.html" class="external-link">sf::st_is_within_distance()</a></code> can be
several orders of magnitude. As a practical example, evaluating
<code><a href="https://r-spatial.github.io/sf/reference/geos_binary_pred.html" class="external-link">sf::st_is_within_distance()</a></code> with a search radius of 10 m
for 38,522 trees from an ALS inventory on a modern laptop took 750.73
sec (around 12 min 31 sec), while computing the Braathe index with the
same settings for all these trees with<code><a href="../reference/compete_inv.html">compete_inv()</a></code> took
16.38 seconds.</p>
<p>If target trees have already been specified with
<code>target_inv()</code>, the outcome can directly be passed to
<code><a href="../reference/compete_inv.html">compete_inv()</a></code>, which then ignores the target_source
argument and all further arguments that are passed on to
<code><a href="../reference/read_inv.html">read_inv()</a></code> and <code><a href="../reference/define_target.html">define_target()</a></code>.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># compute Hegyi index based on existing 'target_inv' object</span></span>
<span> <span class="op">(</span><span class="va">CI1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/compete_inv.html">compete_inv</a></span><span class="op">(</span>inv_source <span class="op">=</span> <span class="va">targets4</span>, radius <span class="op">=</span> <span class="fl">8</span>, </span>
<span>                    method <span class="op">=</span> <span class="st">"CI_Hegyi"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; --------------------------------------------------------------------- </span></span>
<span><span class="co">#&gt; 'compete_inv' class inventory with distance-based competition indices </span></span>
<span><span class="co">#&gt; Results for 43 target trees based on an inventory with 131 trees. </span></span>
<span><span class="co">#&gt; Source of target trees: buffer around edge    Search radius: 8 m</span></span>
<span><span class="co">#&gt; ---------------------------------------------------------------------</span></span>
<span><span class="co">#&gt;         id        x       y    dbh height CI_Hegyi</span></span>
<span><span class="co">#&gt;     &lt;char&gt;    &lt;num&gt;   &lt;num&gt;  &lt;num&gt;  &lt;num&gt;    &lt;num&gt;</span></span>
<span><span class="co">#&gt;  1:  21277 563160.3 5508586  9.863 12.098    0.952</span></span>
<span><span class="co">#&gt;  2:  21512 563166.9 5508589 11.917 12.720    4.971</span></span>
<span><span class="co">#&gt;  3:  21581 563158.5 5508589 12.085 14.659    0.937</span></span>
<span><span class="co">#&gt; ---                                               </span></span>
<span><span class="co">#&gt; 41:  23501 563157.4 5508615 26.787 27.172    2.286</span></span>
<span><span class="co">#&gt; 42:  23582 563139.6 5508616  9.186 11.461    6.138</span></span>
<span><span class="co">#&gt; 43:  23652 563141.8 5508616 11.017 13.886    5.866</span></span></code></pre></div>
<p>The resulting “compete_inv” object contains only the target trees,
and has one additional column for each computed competition index.
Information about the neighbour trees as well as information about the
methods are stored as attributes.</p>
<p>In addition to analyses based on existing “target_inv” objects, it is
possible to read data from file, for example from a “.csv” source with
non-standard column names and decimal and field separators (in this
example, from a German file source):</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CI2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/compete_inv.html">compete_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="st">"data/inventory5.csv"</span>,</span>
<span>  target_source <span class="op">=</span> <span class="st">"buff_edge"</span>,</span>
<span>  radius <span class="op">=</span> <span class="fl">10</span>, </span>
<span>  method <span class="op">=</span> <span class="st">"CI_Hegyi"</span>,</span>
<span>  x <span class="op">=</span> <span class="va">Koord_x</span>, </span>
<span>  y <span class="op">=</span> <span class="va">Koord_y</span>,</span>
<span>  id <span class="op">=</span> <span class="va">Baumname</span>,</span>
<span>  dbh <span class="op">=</span> <span class="va">Durchmesser</span>,</span>
<span>  sep <span class="op">=</span> <span class="st">";"</span>,</span>
<span>  dec <span class="op">=</span> <span class="st">","</span></span>
<span>  <span class="op">)</span></span>
<span><span class="co">#&gt; The following columns were used to create the inventory dataset:</span></span>
<span><span class="co">#&gt; id     ---   Baumname</span></span>
<span><span class="co">#&gt; x      ---   Koord_x</span></span>
<span><span class="co">#&gt; y      ---   Koord_y</span></span>
<span><span class="co">#&gt; dbh  --- Durchmesser</span></span></code></pre></div>
<p>The output of this function can then again be inspected in the same
way as above using <code><a href="../reference/plot_target.html">plot_target()</a></code> to make sure the selection
of target trees make sense:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot_target.html">plot_target</a></span><span class="op">(</span><span class="va">CI2</span><span class="op">)</span></span></code></pre></div>
<p><img src="../reference/figures/comp1.png" alt="plot_trees" width="600"></p>
</div>
<div class="section level3">
<h3 id="available-competition-indices">Available competition indices<a class="anchor" aria-label="anchor" href="#available-competition-indices"></a>
</h3>
<p>The function computes a series of inventory-based competition indices
commonly used in the literature that can be specified via the
<code>method</code> argument (<a href="https://search.worldcat.org/title/growth-models-for-tree-and-stand-simulation-proceedings-of-meetings-in-1973/oclc/1273734" class="external-link">Hegyi
1974</a>; Braathe, 1980; <a href="https://doi.org/10.1139/x97-012" class="external-link">Rouvinen &amp; Kuuluvainen,
1997</a>; see also <a href="https://doi.org/10.1016/j.foreco.2011.08.031" class="external-link">Contreras et al.,
2011</a>). These are either based on tree diameter at breast height
(“CI_Hegyi”, “CI_RK1”, “CI_RK2”) or on tree height (“CI_Braathe”,
“CI_RK3”, “CI_RK4”).</p>
<p>The competition indices are computed according to the following
equations, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>i</mi></msub><annotation encoding="application/x-tex">h_i</annotation></semantics></math>
are the dbh and height of neighbour tree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>
are dbh and height of the target tree, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dist_i</annotation></semantics></math>
is the distance from neighbour tree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
to the target tree.</p>
<p><strong>Diameter-based competition indices</strong></p>
<p><strong>CI_Hegyi</strong> introduced by Hegyi (1974):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>H</mi><mi>e</mi><mi>g</mi><mi>y</mi><mi>i</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>d</mi><mi>i</mi></msub><mrow><mi>d</mi><mo>⋅</mo><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">CI_{Hegyi} = \sum_{i=1}^{n} \frac{d_{i}} {d \cdot dist_{i}}</annotation></semantics></math><strong>CI_RK1</strong> according to CI1 Rouvinen &amp; Kuuluvainen
(1997):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>R</mi><mi>K</mi><mn>1</mn></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>d</mi><mi>i</mi></msub><mrow><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CI_{RK1} = \sum_{i=1}^{n} \mathrm{arctan}\left(\frac{d_{i} } {dist_{i}}\right)</annotation></semantics></math><strong>CI_RK2</strong> according to CI3 in Rouvinen &amp; Kuuluvainen
(1997):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>R</mi><mi>K</mi><mn>2</mn></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>d</mi><mi>i</mi></msub><mi>d</mi></mfrac><mo>⋅</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>d</mi><mi>i</mi></msub><mrow><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CI_{RK2} =\sum_{i=1}^{n} \frac{d_{i}}{d} \cdot \mathrm{arctan}\left(\frac{d_{i} } {dist_{i}}\right)</annotation></semantics></math></p>
<p><strong>Height-based competition indices</strong></p>
<p><strong>CI_Braathe</strong> according to Braathe (1980):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>B</mi><mi>r</mi><mi>a</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>e</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>h</mi><mi>i</mi></msub><mrow><mi>h</mi><mo>⋅</mo><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">CI_{Braathe} = \sum_{i=1}^{n} \frac{h_{i}}{h \cdot dist_{i}}</annotation></semantics></math><strong>CI_RK3</strong> according to CI5 in Rouvinen &amp; Kuuluvainen
(1997):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>R</mi><mi>K</mi><mn>3</mn></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>h</mi><mi>i</mi></msub><mrow><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CI_{RK3} = \sum_{i=1}^{n}  \mathrm{arctan}\left(\frac{h_{i}}{ dist_{i}}\right)</annotation></semantics></math>
for all trees with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>&gt;</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">h_{i} &gt; h</annotation></semantics></math><strong>CI_RK4</strong> based on CI3 in Rouvinen &amp; Kuuluvainen
(1997) and Contreras et al. (2011):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>R</mi><mi>K</mi><mn>4</mn></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>h</mi><mi>i</mi></msub><mi>h</mi></mfrac><mo>⋅</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>h</mi><mi>i</mi></msub><mrow><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">CI_{RK4} = \sum_{i=1}^{n} \frac{h_{i}}{ h } \cdot    \mathrm{arctan}\left(\frac{h_{i}}{ dist_{i}}\right)</annotation></semantics></math></p>
<p><strong>Generic size-based Hegyi-type competition index</strong></p>
<p><strong>CI_size</strong> based on Hegyi (1974), but with a
user-specified size-related variable
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>:
size for neighbour tree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>:
size of the target tree):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>I</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msub><mi>s</mi><mi>i</mi></msub><mrow><mi>s</mi><mo>⋅</mo><mi>d</mi><mi>i</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">CI_{size} = \sum_{i=1}^{n} \frac{s_{i}}{s \cdot dist_{i}}</annotation></semantics></math></p>
<p>An advantage of the classical distance-based indices (CI_Hegyi and
CI_Braathe) is their clear interpretation as the sum of the relative
sizes of the neighbour trees relative to the target tree size, weighted
by their distance to the target tree.</p>
<p>If <code>method = "all_methods"</code> (the standard setting),
<code><a href="../reference/compete_inv.html">compete_inv()</a></code> computes all indices that can be computed
with the data available in the inventory.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CI3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/compete_inv.html">compete_inv</a></span><span class="op">(</span>inv_source <span class="op">=</span> <span class="va">targets4</span>, </span>
<span>                    radius <span class="op">=</span> <span class="fl">8</span>, method <span class="op">=</span> <span class="st">"all_methods"</span><span class="op">)</span></span>
<span><span class="va">CI3</span><span class="op">[</span>, <span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span><span class="op">]</span> <span class="co"># remove coordinates to make room for printing</span></span>
<span><span class="co">#&gt; --------------------------------------------------------------------- </span></span>
<span><span class="co">#&gt; 'compete_inv' class inventory with distance-based competition indices </span></span>
<span><span class="co">#&gt; Results for 43 target trees based on an inventory with 131 trees. </span></span>
<span><span class="co">#&gt; Source of target trees: buffer around edge    Search radius: 8 m </span></span>
<span><span class="co">#&gt; ---------------------------------------------------------------------</span></span>
<span><span class="co">#&gt;         id    dbh height CI_Hegyi CI_RK1 CI_RK2 CI_Braathe CI_RK3 CI_RK4</span></span>
<span><span class="co">#&gt;     &lt;char&gt;  &lt;num&gt;  &lt;num&gt;    &lt;num&gt;  &lt;num&gt;  &lt;num&gt;      &lt;num&gt;  &lt;num&gt;  &lt;num&gt;</span></span>
<span><span class="co">#&gt;  1:  21277  9.863 12.098    0.952  4.233  6.599      0.909  3.702  6.208</span></span>
<span><span class="co">#&gt;  2:  21512 11.917 12.720    4.971 14.872 38.159      4.098 13.663 30.618</span></span>
<span><span class="co">#&gt;  3:  21581 12.085 14.659    0.937  4.258  7.277      0.843  2.663  6.439</span></span>
<span><span class="co">#&gt; ---                                                                     </span></span>
<span><span class="co">#&gt; 41:  23501 26.787 27.172    2.286 15.139 17.242      1.849  8.308 13.240</span></span>
<span><span class="co">#&gt; 42:  23582  9.186 11.461    6.138 16.847 43.552      4.679 14.254 32.146</span></span>
<span><span class="co">#&gt; 43:  23652 11.017 13.886    5.866 17.400 42.582      4.354 12.267 30.132</span></span></code></pre></div>
<p>In this example, the inventory contained both dbh and height, but no
user-specified size, and accordingly all built-in indices except the
CI_size are included in the output.</p>
</div>
<div class="section level3">
<h3 id="choosing-a-search-radius">Choosing a search radius<a class="anchor" aria-label="anchor" href="#choosing-a-search-radius"></a>
</h3>
<p>All indices that can be calculated with <code><a href="../reference/compete_inv.html">compete_inv()</a></code>
are based on a distance-weighted sum of the relative size of all
neighbour trees within the search radius compared to the size of the
central tree, or a sum of a transformation thereof. As the search radius
determines how many trees are included for calculating these metric for
each tree, all these distance-based competition indices are extremely
sensitive to the choice of the search radius. An obvious consequence of
this is that it is not possible to meaningfully compare distance-based
competition indices calculated with different search radii. Perhaps less
obvious is that the optimal search radius may differ between species, as
different tree species have different average sizes and rooting
patterns, and that comparisons between species using competition indices
calculated with the same settings may not always yield meaningful
results. Some authors recommend using a search radius based on the
average crown size of the trees in the plot, such as <a href="https://doi.org/10.1016/0378-1127(83)90042-7" class="external-link">Lorimer (1983)</a>,
who suggests a search radius of 3.5 average crown radii. While such a
recommendation certainly makes more sense than sticking to standard
values such as 10 m, regardless of whether you are calculating
competition for stunted Elfin forests or gigantic Redwood trees,
ultimately such a setting will always be arbitrary and there are limits
to the comparability of indices between studies and between species.</p>
</div>
<div class="section level3">
<h3 id="user-specified-competition-indices">User-specified competition indices<a class="anchor" aria-label="anchor" href="#user-specified-competition-indices"></a>
</h3>
<p>With <code>TreeCompR</code>, defining user-specified competition
indices is very easy. All it takes is to write a function that takes the
arguments <code>target</code> and <code>neigh</code> as its inputs, and
returns a single numeric value (the value of the competition index for
the current tree) as an output. Here <code>target</code> is a
single-line “forest_inv”-based data.table with the data of a target
tree, and <code>neigh</code> is a multi-line “forest_inv”-based
data.table with the data of all neighbor trees of the target tree
(including their distance “dist` to the target tree). This function will
then be evaluated for all target trees to calculate their value of the
index.</p>
<p>For instance, a working version of the Hegyi index can be defined
like this:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CI_Hegyi_new</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">)</span>  <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">neigh</span><span class="op">$</span><span class="va">dbh</span> <span class="op">/</span> <span class="op">(</span><span class="va">target</span><span class="op">$</span><span class="va">dbh</span> <span class="op">*</span> <span class="va">neigh</span><span class="op">$</span><span class="va">dist</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>This function can then be called with the <code>method</code>
argument <code><a href="../reference/compete_inv.html">compete_inv()</a></code> as a competition index:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/compete_inv.html">compete_inv</a></span><span class="op">(</span>inv_source <span class="op">=</span> <span class="va">targets4</span>, radius <span class="op">=</span> <span class="fl">8</span>,</span>
<span>            method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"CI_Hegyi"</span>, <span class="st">"CI_Hegyi_new"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; --------------------------------------------------------------------- </span></span>
<span><span class="co">#&gt; 'compete_inv' class inventory with distance-based competition indices </span></span>
<span><span class="co">#&gt; Results for 43 target trees based on an inventory with 131 trees. </span></span>
<span><span class="co">#&gt; Source of target trees: buffer around edge    Search radius: 8 m </span></span>
<span><span class="co">#&gt; ---------------------------------------------------------------------</span></span>
<span><span class="co">#&gt;         id        x       y    dbh height CI_Hegyi CI_Hegyi_new</span></span>
<span><span class="co">#&gt;     &lt;char&gt;    &lt;num&gt;   &lt;num&gt;  &lt;num&gt;  &lt;num&gt;    &lt;num&gt;        &lt;num&gt;</span></span>
<span><span class="co">#&gt;  1:  21277 563160.3 5508586  9.863 12.098    0.952        0.952</span></span>
<span><span class="co">#&gt;  2:  21512 563166.9 5508589 11.917 12.720    4.971        4.971</span></span>
<span><span class="co">#&gt;  3:  21581 563158.5 5508589 12.085 14.659    0.937        0.937</span></span>
<span><span class="co">#&gt; ---                                                            </span></span>
<span><span class="co">#&gt; 41:  23501 563157.4 5508615 26.787 27.172    2.286        2.286</span></span>
<span><span class="co">#&gt; 42:  23582 563139.6 5508616  9.186 11.461    6.138        6.138</span></span>
<span><span class="co">#&gt; 43:  23652 563141.8 5508616 11.017 13.886    5.866        5.866</span></span></code></pre></div>
<p>The output is identical to the built-in function.</p>
<p>This feature can also be used to modify existing indices, e.g. by
calculating the RK2 index only for trees that are taller than the target
tree:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CI_RK1_tall</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">)</span> </span>
<span>  <span class="fu"><a href="../reference/competition_indices.html">CI_RK1</a></span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">[</span><span class="va">neigh</span><span class="op">$</span><span class="va">height</span> <span class="op">&gt;</span> <span class="va">target</span><span class="op">$</span><span class="va">height</span>, <span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>In many cases, it can e.g. be interesting to split up the
contribution to the total competition by different competitor species
(see <a href="https://doi.org/10.1111/gcb.16146" class="external-link">Hajek et al., 2022</a>
for an example). This can be done analogously, for example for a mixed
stand of hornbeam, oak and ash:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># define partial index for oak</span></span>
<span><span class="va">CI_Hegyi_QURO</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">)</span> </span>
<span>  <span class="fu"><a href="../reference/competition_indices.html">CI_Hegyi</a></span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">[</span><span class="va">neigh</span><span class="op">$</span><span class="va">species</span> <span class="op">==</span> <span class="st">"Quercus robur"</span>, <span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># define partial index for hornbeam</span></span>
<span><span class="va">CI_Hegyi_CABE</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">)</span> </span>
<span>  <span class="fu"><a href="../reference/competition_indices.html">CI_Hegyi</a></span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">[</span><span class="va">neigh</span><span class="op">$</span><span class="va">species</span> <span class="op">==</span> <span class="st">"Carpinus betulus"</span>, <span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># define partial index for ash</span></span>
<span><span class="va">CI_Hegyi_FREC</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">)</span> </span>
<span>  <span class="fu"><a href="../reference/competition_indices.html">CI_Hegyi</a></span><span class="op">(</span><span class="va">target</span>, <span class="va">neigh</span><span class="op">[</span><span class="va">neigh</span><span class="op">$</span><span class="va">species</span> <span class="op">==</span> <span class="st">"Fraxinus excelsior"</span>, <span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># load complete dataset (keep rest: information about species etc is maintained)</span></span>
<span><span class="va">inv_species</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/read_inv.html">read_inv</a></span><span class="op">(</span><span class="st">"data/inventory6.csv"</span>, keep_rest <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu">form</span><span class="op">(</span><span class="va">inv_species</span><span class="op">)</span></span>
<span><span class="co">#&gt; ---------------------------------------  </span></span>
<span><span class="co">#&gt; 'forest_inv' class inventory dataset: </span></span>
<span><span class="co">#&gt; collection of 1091 observations </span></span>
<span><span class="co">#&gt; ---------------------------------------</span></span>
<span><span class="co">#&gt;           id      x       y    dbh height            species</span></span>
<span><span class="co">#&gt;       &lt;char&gt;  &lt;num&gt;   &lt;num&gt;  &lt;num&gt;  &lt;num&gt;             &lt;char&gt;</span></span>
<span><span class="co">#&gt;    1:  31316 26.630   0.722 10.693 15.061   Carpinus betulus</span></span>
<span><span class="co">#&gt;    2:  31339  6.338   0.712  6.668 10.162   Carpinus betulus</span></span>
<span><span class="co">#&gt;    3:  31374  4.718   0.792  6.603  9.240 Fraxinus excelsior</span></span>
<span><span class="co">#&gt;   ---                                                       </span></span>
<span><span class="co">#&gt; 1089:  38564 46.397 100.414  4.850  7.597 Fraxinus excelsior</span></span>
<span><span class="co">#&gt; 1090:  38565 54.600  99.893  5.804  8.178   Carpinus betulus</span></span>
<span><span class="co">#&gt; 1091:  38567 94.888 100.531  3.412  6.133   Carpinus betulus</span></span>
<span></span>
<span></span>
<span><span class="co"># compute species-decomposed Hegyi</span></span>
<span><span class="va">comp_species</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/compete_inv.html">compete_inv</a></span><span class="op">(</span></span>
<span>  inv_source <span class="op">=</span> <span class="va">inv_species</span>, target_source <span class="op">=</span> <span class="st">"buff_edge"</span>, radius <span class="op">=</span> <span class="fl">12</span>, </span>
<span>  method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"CI_Hegyi_QURO"</span>, <span class="st">"CI_Hegyi_CABE"</span>, <span class="st">"CI_Hegyi_FREC"</span>, <span class="st">"CI_Hegyi"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">comp_species</span><span class="op">[</span>, <span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#&gt; --------------------------------------------------------------------- </span></span>
<span><span class="co">#&gt; 'compete_inv' class inventory with distance-based competition indices </span></span>
<span><span class="co">#&gt; Results for 622 target trees based on an inventory with 1090 trees. </span></span>
<span><span class="co">#&gt; Source of target trees: buffer around edge    Search radius: 12 m </span></span>
<span><span class="co">#&gt; ---------------------------------------------------------------------</span></span>
<span><span class="co">#&gt;                 species CI_Hegyi_QURO CI_Hegyi_CABE CI_Hegyi_FREC CI_Hegyi</span></span>
<span><span class="co">#&gt;                  &lt;char&gt;         &lt;num&gt;         &lt;num&gt;         &lt;num&gt;    &lt;num&gt;</span></span>
<span><span class="co">#&gt;   1:      Quercus robur        12.514         8.501         4.086   25.101</span></span>
<span><span class="co">#&gt;   2: Fraxinus excelsior         5.045         1.529         3.396    9.971</span></span>
<span><span class="co">#&gt;   3: Fraxinus excelsior         6.303         2.955         3.156   12.414</span></span>
<span><span class="co">#&gt;  ---                                                                      </span></span>
<span><span class="co">#&gt; 620:   Carpinus betulus         3.771         1.582         1.329    6.682</span></span>
<span><span class="co">#&gt; 621:      Quercus robur         2.006         1.977         1.372    5.355</span></span>
<span><span class="co">#&gt; 622:      Quercus robur         3.349         2.888         1.571    7.807</span></span></code></pre></div>
<p>As in the plot the three species are the only species that occur,
this constitutes a full decomposition of the Hegyi index into the
contributions of different competitor species:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># test if the decomposition worked</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/with.html" class="external-link">with</a></span><span class="op">(</span><span class="va">comp_species</span>, </span>
<span>     <span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">CI_Hegyi_QURO</span> <span class="op">+</span> <span class="va">CI_Hegyi_CABE</span> <span class="op">+</span> <span class="va">CI_Hegyi_FREC</span>, <span class="va">CI_Hegyi</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>As species-specific directed interaction are likely very common among
competing tree species, such a decomposition may often be more
beneficial for understanding competition between trees than looking at
the overall effect of competition.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Julia S. Rieder, Roman M. Link.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
