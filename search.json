[{"path":"https://juliarieder.github.io/TreeCompR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 TreeCompR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"workflow-for-deriving-size-distance-dependent-competition-indizes-from-als-data","dir":"Articles","previous_headings":"","what":"Workflow for deriving size-distance-dependent competition indizes from ALS data","title":"ALS competition workflow","text":"Airborne Laser Scanning powerful tool forest management research, offering accurate large-scale data. quantify competition individual tree level, first ALS point cloud needs pre-processed. using data TreeCompR, need segment trees derive inventory table. package lidR great option load,inspect process ALS data segment individual trees. Check lidRbook nice detailed workflows examples.","code":"library(lidR) library(TreeCompR)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"read-the-point-cloud","dir":"Articles","previous_headings":"","what":"Read the point cloud","title":"ALS competition workflow","text":"lidR package can read various data formats. Read raw ALS point cloud. show workflow example data lidR package. Maybe just load xyz save memory, case lot parameters stored data, using optional parameter select within readLAS(). always good check validate data using las_check() function.","code":"LASfile <- system.file(\"extdata\", \"Megaplot.laz\", package=\"lidR\") las <- readLAS(LASfile) #print a summary print(las) las <- readLAS(\"file.las\", select = \"xyz\")  # load XYZ only las_check(las)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"plot-your-data","dir":"Articles","previous_headings":"","what":"Plot your data","title":"ALS competition workflow","text":"Please note, various options individual tree segmentations (e.g. based point cloud canopy height model). aware, based data, might need test approaches results check visually, results realistic. segmentation based CHM, first CHM needs generated:","code":"plot(las) # create CHM raster from point cloud with 0.5 m resolution (adjust values if needed) chm_p2r_05 <- rasterize_canopy(las, 0.5, p2r(subcircle = 0.2), pkg = \"terra\")  # Post-processing median filter kernel <- matrix(1,3,3) chm_p2r_05_smoothed <- terra::focal(chm_p2r_05, w = kernel, fun = median, na.rm = TRUE)  #locate tree tops ttops_chm_p2r_05_smoothed <- locate_trees(chm_p2r_05_smoothed, lmf(5)) col <- height.colors(50) plot(chm_p2r_05_smoothed, main = \"CHM P2R 0.5 smoothed\", col = col);  plot(sf::st_geometry(ttops_chm_p2r_05_smoothed), add = T, pch =3)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"segment-the-trees","dir":"Articles","previous_headings":"","what":"Segment the trees","title":"ALS competition workflow","text":"","code":"algo <- dalponte2016(chm_p2r_05_smoothed, ttops_chm_p2r_05_smoothed) las <- segment_trees(las, algo) # segment point cloud plot(las, bg = \"white\", size = 4, color = \"treeID\") # visualize trees"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"get-crown-metrics","dir":"Articles","previous_headings":"","what":"Get crown metrics","title":"ALS competition workflow","text":"","code":"crowns <- crown_metrics(las, func = .stdtreemetrics, geom = \"convex\") plot(crowns[\"convhull_area\"], main = \"Crown area (convex hull)\") trees <- crown_metrics(las, func = .stdtreemetrics, geom = \"point\") plot(trees[\"Z\"], main = \"Tree heights\", pch = 16)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"integration-into-treecompr","dir":"Articles","previous_headings":"","what":"Integration into TreeCompR","title":"ALS competition workflow","text":"Extract inventory table crown data: validate inventory table read_inv() define target trees (automatically) define_targets() trees edge plot dataset (1 search radius away plot edge) automatically excluded calculating CIs.  Now can calculate tree competition (size-distance-dependent) trees. Afterwards can print results, save dataframe plot results according needs.","code":"library(sf) library(dplyr) inventory <- trees %>%   mutate(x = st_coordinates(.)[,1], y = st_coordinates(.)[,2]) %>%   st_set_geometry(NULL) head(inventory) #>    treeID     Z npoints convhull_area        x       y #> 1:     15 18.53      51        19.995 684807.0 5018005 #> 2:     16 20.66      88        39.888 684838.7 5018006 #> 3:     17 17.82      73        27.695 684892.5 5018007 #> 4:     18 13.55      51        23.316 684909.6 5018006 #> 5:     19 22.00      69        34.506 684770.2 5018006 #> 6:     20 17.75      28        19.758 684980.1 5018005 inv_trees <- read_inv(inventory, height = Z, height_unit = \"m\") #> The following columns were used to create the inventory dataset: #> id   --- treeID #> x    --- x #> y    --- y #> height   --- Z targets_buff <- define_target(inv_trees, target_source = \"buff_edge\", radius = 10) plot_target(targets_buff) CI <- compete_inv(inv_source = inv_trees, target_source = \"buff_edge\",                    radius = 10, method = \"all\") CI #> ---------------------------------------------------------------------  #> 'compete_inv' class inventory with distance-based competition indices  #> Collection of data for 671 target and 220 edge trees.  #> Source of target trees: buffer around edge    Search radius: 10  #> --------------------------------------------------------------------- #>      id         x          y height CI_Braathe CI_RK3 CI_RK4 #> 45   61 684895.13 5017995.17  17.44      0.621  3.564   5.29 #> 50   67 684812.86 5017994.96  24.26      0.494  2.633  4.222 #> 57   74 684806.23 5017990.75  25.68      1.179  7.868 10.898 #>     ...       ...        ...    ...        ...    ...    ... #> 871 900 684966.93 5017806.91  18.44      0.737  4.914  5.585 #> 874 903 684975.75 5017803.27     19      0.705  1.173  5.863 #> 881 910 684959.15 5017797.96  16.03       0.77  3.689  5.311"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"plot-the-results","dir":"Articles","previous_headings":"","what":"plot the results","title":"ALS competition workflow","text":"","code":"library(ggplot2) ggplot(CI, aes(x = x, y = y, color = CI_Braathe)) +   geom_point(size = 2, alpha = 0.7) + # Adjust point size and transparency   scale_color_gradient(low = \"yellow\", high = \"darkred\",                         name = \"CI Braathe\") + # Customizing color scale   theme_classic() + # Change the theme   labs(title = \"Competition based on tree heights and distance\",         x = \"X\", y = \"Y\") + # Add title and axis labels   theme(     plot.title = element_text(hjust = 0.5), # Center the plot title     legend.position = \"right\" # Position of the legend   )"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"other-options-to-pre-process-the-als-point-clouds","dir":"Articles","previous_headings":"","what":"Other options to pre-process the ALS point clouds","title":"ALS competition workflow","text":"packages available, e.g. itcSegment package. Within function itcLiDARallo(), trees segmented based typical allometric relations can defined beforehand. also used approach settings pre-process MLS data manuscript “TreeCompR: Tree competition indices inventory data 3D point clouds”. used publicly available laser scanning datasets Bavarian Agency Digitisation, High-Speed Internet Surveying.","code":"library(itcSegment)   # create a lookup table with common height-crown diameter-relations  # (example from itcSegment, also used in our case study) lut <- data.frame(   H = c(2, 10, 15, 20, 25, 30),   CD = c(0.5, 1, 2, 3, 4, 5))  #create a digital terrain model dtm <- grid_terrain(las = las, res = 0.5, algorithm = knnidw(k=10L, p=2)) plot(dtm) #normalize the height of the las data by terrain nlas <- las - dtm  # segment the trees (adjust epsg according to your coordinate reference system) se<-itcLiDARallo(nlas$X,nlas$Y,nlas$Z,epsg=32632,lut=lut) summary(se) plot(se,axes=T)  #validate the output in TreeCompR inv_trees <- read_inv(se, height = Height_m, height_unit = \"m\") #quantify tree competition (adjust radius) compete_inv(inv_source = inv_trees, target_source = \"buff_edge\",              radius = 13.5, method = \"all\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html","id":"pre-processing-of-tls-or-mls-point-clouds","dir":"Articles","previous_headings":"","what":"Pre-processing of TLS or MLS point clouds","title":"TLS competition workflow","text":"extracting information tree level close-range laser scanning (TLS MLS), can use e.g. TreeLS package. show workflow implement output TreeLS within TreeCompR. First, load .las data, normalize height, sample point cloud, estimate tree occurrence regions, classify stem points estimate diameter height individual tree.","code":"library(TreeCompR) library(TreeLS) file <- \"path/to/file\"     tls <- readTLS(file)     tls_norm <- tlsNormalize(tls, keep_ground = F)     thin <- tlsSample(tls_norm, smp.voxelize(0.01))     map <- treeMap(thin, map.hough(min_density = 0.1), 0)     tls_t <- treePoints(tls_norm, map, trp.crop())     tls_stem <- stemPoints(tls_t, stm.hough())     inv <- tlsInventory(tls_stem, d_method=shapeFit(shape='circle',                                                      algorithm = 'ransac'))     inv$dbh <- (inv$Radius * 2)     head(inv) #>    TreeID         X          Y     Radius        Error        H h_radius        dbh #> 1:      1 12.039168  3.3932670 0.44487714 0.0008539910 24.72817      1.3 0.88975428 #> 2:      2 11.930523  2.3763304 0.13060774 0.0005245504 24.98053      1.3 0.26121547 #> 3:      3  7.424479 -4.9563841 0.09487961 0.0003207291 23.75091      1.3 0.18975922 #> 4:      4  7.144895  5.8221160 0.49786606 0.0004321285 24.05617      1.3 0.99573212 #> 5:      5  7.085920  0.8309956 0.08171301 0.0002994584 24.07538      1.3 0.16342603 #> 6:      6  7.183327  5.2498770 0.04965389 0.0004974247 23.94043      1.3 0.09930777"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html","id":"use-extracted-tree-information-within-treecompr","dir":"Articles","previous_headings":"","what":"Use extracted tree information within TreeCompR","title":"TLS competition workflow","text":"ensure inventory data assigned correctly, check data make sure specify units dbh height differ default, cm dbh m height. Use read_inv() validate inventory data within TreeCompR. visually check trees CIs quantified depending chosen search radius, can use define_target() plot_target(). recommend use target_source = \"buff_edge\" automatically calculate CI trees plot except less one search radius away forest edge. specifically important TLS/MLS data, since data types usually cover small forest plots rather whole forests.","code":"inventory <- read_inv(inv_source = inv, dbh_unit = \"m\", height_unit = \"m\") targets <- define_target(inv = inventory, target_source = \"buff_edge\", radius = 10) plot_target(targets) compete_inv(inventory, target_source = \"buff_edge\", radius = 7,                method = \"all_methods\") #>---------------------------------------------------------------  #> 'target_inv' class inventory dataset with defined target trees:  #> collection of 31 observations  #> Source of target trees: buffer around edge  #> --------------------------------------------------------------- #>     id      x      y   dbh height target #> 1    1 12.039  3.393  0.89 24.728  FALSE #> 2    2 11.931  2.376 0.261 24.981  FALSE #> 3    3  7.424 -4.956  0.19 23.751  FALSE #>    ...    ...    ...   ...    ...    ... #> 29  35 -6.407 -4.719  0.06 19.791  FALSE #> 30  36 -7.484 -7.635 0.216 22.478  FALSE #> 31  38 -5.287  1.051  0.06 22.923  FALSE"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html","id":"use-cases","dir":"Articles","previous_headings":"","what":"Use cases","title":"TLS competition workflow","text":"","code":"## If you focus on a specific CI, e.g. the widely used Hegyi-Index,  ## you can choose it within methods = \"CI_Hegyi\". #> compete_inv(inventory, target_source = \"buff_edge\", radius = 7,  #>              method = \"CI_Hegyi\") #> The following columns were used to create the inventory dataset: #> id   --- TreeID #> x    --- X #> y    --- Y #> dbh  --- dbh #> height   --- H #>  #> ---------------------------------------------------------------------  #> 'compete_inv' class inventory with distance-based competition indices  #> Collection of data for 1 target and 30 edge trees.  #> Source of target trees: buffer around edge    Search radius: 7  #> --------------------------------------------------------------------- #>    id ...  dbh height CI_Hegyi CI_Braathe CI_RK1 CI_RK2 CI_RK3 CI_RK4 #> 18 20 ... 0.25   23.9     1.96       2.07   0.49  0.499    4.1   13.2  ## If you have a tree height column that is not automatically recognized within  ## our validation of input data, you can set it manually: # in read_inv(): inventory <- read_inv(inv_source = inventory, height = \"h_column_name\")  # in compete_inv(): compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                height = \"h_column_name\", method = \"CI_Hegyi\")  ## If your dbh is specified in cm, just change the dbh_unit to \"cm\" compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                dbh_unit = \"cm\", method = \"CI_Hegyi\")  ## If you want to keep a column with certain user defined IDs for the trees,  ## and it is not recognized, specify it with id = \"name_column\" inventory <- read_inv(inv_source = inventory, id = \"ID_user\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"TreeCompR","text":"can install stable version (main branch) well current development version TreeCompR (development branch: --date, potentially unstable) GitHub :","code":"# install.packages(\"devtools\")  # get stable version devtools::install_github(\"juliarieder/TreeCompR\")  # get development branch  devtools::install_github(\"juliarieder/TreeCompR\", ref = \"development\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"TreeCompR","text":"TreeCompR can read point clouds inventory tables quantify tree competition different ways: compete_pc() quantifies tree competition point clouds using cone cylinder method (see Metz et al. 2013;Seidel et al. 2015) read_pc() reads 3D point clouds .las/.laz files, .ply files text-file formats .txt .csv, converts LAS objects data.frames TreeCompR compatible format tree_pos() computes base position height target tree point clouds compete_inv() quantifies size- distance-dependent competition using inventory data based series published indices read_inv() reads validates inventory tables data.frames, reads tabular data directly text-file sources .txt .csv define_target() can used define trees within plot competition quantified compete_inv() plot_target() check validate tree position(s) surrounding trees defining define_target()","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"methodology-of-the-point-cloud-based-approach","dir":"Articles","previous_headings":"","what":"Methodology of the point cloud-based approach","title":"TreeCompR","text":"LiDAR point clouds can used directly quantify competition exerted neighboring trees target tree. purpose, target tree competition determined segmented beforehand. Since crucial whether part point cloud classified “competing” part target tree , manual segmentation (e.g. CloudCompare) recommended tends much accurate.","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"point-cloud-based-tree-competition-metrics","dir":"Articles","previous_headings":"Examples","what":"Point-cloud based tree competition metrics","title":"TreeCompR","text":"compete_pc(), easy quantify competition compete_pc() one target tree, example using cone method (counts amount voxels belonging competitor trees situated cone opening 60 % target tree’s height angle 60 degrees): Equivalently, cylinder method can used count amount voxels belonging competitor trees within cylinder around target tree 5 m radius. examples use default settings compete_pc(), function highly customizable able deal large number different file formats object types, majority identified read automatically. cases possible due non-standard file structures, point clouds can loaded pre-processed outside compete_pc() using read_pc() custom settings functions passed compete_pc().","code":"library(TreeCompR) ## insert path to point cloud of the forest plot and to the target tree  compete_pc(forest_source = \"../tests/testthat/testdata/neighborhood.txt\",             tree_source = \"../tests/testthat/testdata/tree.txt\",             comp_method = \"cone\",            h_cone = 0.6,            print_progress = \"none\") # suppress messages  #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cone h_cone #> 1   tree          22.8    crown center   16046    0.6 ## or the cylinder method with radius 5 m compete_pc(forest_source = \"../tests/testthat/testdata/neighborhood.las\",             tree_source = \"../tests/testthat/testdata/tree.las\",             comp_method = \"cylinder\",            cyl_r = 5,            print_progress = \"none\") # suppress messages  #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cyl cyl_r #> 1   tree          22.8    crown center 102169     5"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"size--and-distance-dependent-tree-competition-metrics","dir":"Articles","previous_headings":"Examples","what":"Size- and distance-dependent tree competition metrics","title":"TreeCompR","text":"Analogously, distance-dependent competition indices can quantified using compete_inv(), can read text file spatial positions trees measures size (conventionally, diameter breast height tree height). usually advisable compute competition indices trees plot strong edge effects sample trees comprise entire forest stand, compete_inv() necessary explicitly specify target trees. cases priori defined design study, possible automatically identify target trees using define_target() function. following example, inventory first read read_inv(), target trees identified define_target(). , read_inv() highly customizable, allows large amount different input formats also manual identification names important variables (x y coordinates tree size). target_source = \"buff_edge, target trees defined trees distance one search radius (case, 10 m) border forest stand (approximated concave hull). many possible settings target_source, specifying target trees IDs, logical subsetting, separate set coordinates. also possible define trees target trees, unless dataset contains trees forest almost never good idea due obvious edge effects. possible plot selection target trees surrounding neighborhood visual inspection using plot_target():  example, neighborhood already chosen contain single tree within 10 m buffer border, consequence, single tree identified potential target tree. target_inv object results call define_target() contains information trees plot well status target neighbor tree, can directly fed compete_inv() calculate competition indices one target tree without specify target trees explicitly: Choosing method = \"\" computes available metrics chosen data source. dataset contains diameters, tree heights, case Hegyi index well RK1 RK2 indices (see documentation compete_inv() paper details).","code":"## read forest inventory file from source plot <- read_inv(\"../tests/testthat/testdata/inventory.csv\", verbose = FALSE) ## define target trees targets <- define_target(plot, target_source = \"buff_edge\", radius = 10) ## plot the positions of the target trees and trees at the border plot_target(targets) ## get competition indices for the selected target trees compete_inv(inv_source = targets,             radius = 10,              method = \"all\")  #> ---------------------------------------------------------------------  #> 'compete_inv' class inventory with distance-based competition indices  #> Collection of data for 1 target and 47 edge trees.  #> Source of target trees: buffer around edge    Search radius: 10  #> --------------------------------------------------------------------- #>    id     x      y   dbh CI_Hegyi CI_RK1 CI_RK2 #> 44 48 0.102 -0.494 0.244     4.39   1.07   1.58"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Quantifying competition from inventory data","text":"Within TreeCompR possible easily derive size-distance-dependent competition indices based inventory data. data can collected field, derived modelled 3D point clouds. Depending input data, necessary pre-processing steps. Check workflows: airborne laser scanning data competition indices: vignette(“ALS_inventory”): ALS workflow ground-based laser scanning data (MLS/TLS) competition indices: TLS workflow","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"analyzing-inventory-data-with-treecompr","dir":"Articles","previous_headings":"","what":"Analyzing inventory data with TreeCompR","title":"Quantifying competition from inventory data","text":"illustrate TreeCompR can included inside tidy workflow, make use tidyverse function throughout tutorial: However, explicitly quote corresponding package functions used tutorial form purrr::map() functions besides magrittr pipe operator %>%.","code":"library(TreeCompR) library(tidyverse)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"reading-in-forest-inventory-data-with-with-read_inv","dir":"Articles","previous_headings":"Analyzing inventory data with TreeCompR","what":"Reading in forest inventory data with with read_inv()","title":"Quantifying competition from inventory data","text":"inventory data must contain x y coordinates individual trees, able compute competition contain least one size-related variable (e.g. height diameter breast height). ensure inventory data assigned correctly, inspect data thoroughly. Make sure specify units dbh height differ default, cm dbh m height. Tree coordinates always specified m. can either use read_inv() validate inventory data convert object type used TreeCompR functions, directly pass data.frames paths files compete_inv(). former especially useful data non-standard column names data structures want fully control parsed. simple case, reading data read_inv() standard settings (except metric tree diameters) looks like : read_inv() flexibly recognize large number different spellings common inventory variables. provided tabular data without explicitly specified variable names, function default takes columns named “X” “Y” (“x” “y”) tree coordinates, looks columns named “height”, “height_m” “h” well “dbh”, “diameter”,“diam”, “d” (capitalization) size-related variables. tree ids taken columns named “id”, “tree_id”, “treeID” “tree.id” (capitalization). special characters besides “.” “_” stripped column names matching. verbose = TRUE, function inform columns automatically identifided avoid errors. variable names automatically recognized, can specify explicitly corresponding arguments either character string length 1 variable name directly specifying name without quotes. example, assume data set (metric) UTM coordinates Spanish source, .e. “dap_cm” (diámetro en altura de pecho) instead dbh “altura” instead height: Non-standard field separators etc. can internally passed data.table::fread() via ... arguments read exotic formats semicolon-separated “.csv” files commas decimal separators used example Germany. many cases, pre-processing inventories based variables coordinates tree size necessary. reason, possible read objects inherit class data.frame (e.g., tibbles, data.tables actual data.frames) read_inv():","code":"inventory1 <- read_inv(   inv_source = \"data/inventory1.csv\",   dbh_unit = \"m\",   height_unit = \"m\")   inventory1 #> ---------------------------------------   #> 'forest_inv' class inventory dataset:  #> collection of 48 observations  #> --------------------------------------- #>     id      x      y    dbh #> 1    1 15.181 -2.979 35.275 #> 2    2 13.097  0.193 20.068 #> 3    3 12.633 -9.445 35.333 #>    ...    ...    ...    ... #> 46  51 -1.639 -4.842 12.605 #> 47  52 -6.409 -4.722  6.035 #> 48  53 -7.485 -7.619 20.065 inventory2 <- read_inv(   inv_source = \"data/inventory2.csv\",     x = utmx,   y = utmy,   dbh = dap_cm,   height = altura,   dbh_unit = \"cm\",    height_unit = \"m\") #> ---------------------------------------   #> 'forest_inv' class inventory dataset:  #> collection of 48 observations  #> --------------------------------------- #>     id      x      y    dbh #> 1    1 15.181 -2.979 35.275 #> 2    2 13.097  0.193 20.068 #> 3    3 12.633 -9.445 35.333 #>    ...    ...    ...    ... #> 46  51 -1.639 -4.842 12.605 #> 47  52 -6.409 -4.722  6.035 #> 48  53 -7.485 -7.619 20.065 inventory1 <- read_inv(   inv_source = \"data/inventory3.csv\",    dbh_unit = \"m\",    height_unit = \"m\",    dec = \",\",   sep = \";\") #> ---------------------------------------   #> 'forest_inv' class inventory dataset:  #> collection of 48 observations  #> --------------------------------------- #>     id      x      y    dbh #> 1    1 15.181 -2.979 35.275 #> 2    2 13.097  0.193 20.068 #> 3    3 12.633 -9.445 35.333 #>    ...    ...    ...    ... #> 46  51 -1.639 -4.842 12.605 #> 47  52 -6.409 -4.722  6.035 #> 48  53 -7.485 -7.619 20.065 # read dataset outside read_inv and filter to the plot in question dat <- readr::read_csv(\"data/inventory4.csv\") %>%    filter(plot_id == \"Plot 1\")    # use read_inv to convert to a forest_inv object that works with TreeCompR functions inventory4 <- read_inv(   inv_source = dat,   dbh = DAP,   dbh_unit = \"cm\",    height_unit = \"m\") #> ---------------------------------------   #> 'forest_inv' class inventory dataset:  #> collection of 48 observations  #> --------------------------------------- #>     id      x      y    dbh #> 1    1 15.181 -2.979 35.275 #> 2    2 13.097  0.193 20.068 #> 3    3 12.633 -9.445 35.333 #>    ...    ...    ...    ... #> 46  51 -1.639 -4.842 12.605 #> 47  52 -6.409 -4.722  6.035 #> 48  53 -7.485 -7.619 20.065"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"designating-target-trees-with-define_target","dir":"Articles","previous_headings":"Analyzing inventory data with TreeCompR","what":"Designating target trees with define_target()","title":"Quantifying competition from inventory data","text":"select target trees computing competition indices, can use function define_target(). many different ways specifying target trees described documentation define_target(). Briefly, can directly supply tree IDs character string, can define based logical vectors, can supply another forest_inv object created read_tree() contains coordinates, finally character string specifying method define target trees (“buff_edge”, “exclude_edge” “all_trees”). Defining targets vector tree IDs look like , assuming want compute competition indices 3 adjacent Fagus sylvatica trees naming scheme: might also want define target trees based logical criterion, instance trees whose ID contains “FASY”: many cases target tree coordinates come different data source different accuracy inventory data, instance perform ground-based study focusing single trees wish derive tree competition ALS sources based GPS coordinates trees. cases, match GPS coordinates tree coordinates derived ALS source (see ALS workflow details derive inventory data ALS sources). cases, possible supply inventory based second set coordinates target_source matched inventory data. IDs ignored (likely automatically generated anyway) matching based closest trees buffer tol m (default tol = 1: matching within 1 m). size-related variables second set coordinates ignored well ensure competition indices based data source: trees inventory desired distance one target trees, receive warning, one equally good match target tree, function fail error. many cases, list priori specified target trees, aim calculate valid competition indices many trees possible. cases, recommend use target_source = \"buff_edge\". automatically designates trees plot least one search radius away plot edge (roughly approximated concave hull) avoid edge effects. specifically important TLS/MLS data classical forest inventories, since contrast ALS-derived datasets data usually cover relatively small forest plot rather entire forests. Setting target_source = \"exclude_edge\" removes trees edge plot without checking close rest trees edge hence less restrictive prone edge effects previous option. use spatially explicit methods defining target trees, make sure inventory contains data one plot currently grouping possible define_target(). want consider larger number plots, consider e.g. mapping plots [purrr::map()] compute output step step. example identify potential target trees run risk excluding potential edge trees computing competition indices search radius 10 m: possible compute competition indices trees (target_source = \"all_trees\"), results warning done good reasons assume edge trees data actually situated forest edge, otherwise intense edge effects: tree straight plot edge, average nearly half tree edge position rectangular plot 3/4 competitors missing data!","code":"# set target trees based on vector with tree ids targets1 <- define_target(   inv = inventory1,    target_source = c(\"FASY-43-27\", \"FASY-43-28\", \"FASY-43-29\")   ) # set target trees based on logical vector targets2 <- define_target(   inv = inventory1,    target_source = grepl(\"FASY\", inventory1$id)   ) # read target tree positions target_pos <- read_inv(\"data/target_tree_gps.csv\", x = gps_x, y = gps_y) # define target trees targets3 <- define_target(   inv = inventory1,    target_source = target_pos,   tol = 1 # match within 1 m accuracy   ) targets4 <- define_target(   inv = inventory1,    target_source = \"buff_edge\",    radius = 10) targets4 #> ---------------------------------------------------------------  #> 'target_inv' class inventory dataset with defined target trees:  #> collection of 48 observations  #> Source of target trees: buffer around edge  #> --------------------------------------------------------------- #>     id      x      y    dbh target #> 1    1 15.181 -2.979 35.275  FALSE #> 2    2 13.097  0.193 20.068  FALSE #> 3    3 12.633 -9.445 35.333  FALSE #>    ...    ...    ...    ...    ... #> 46  51 -1.639 -4.842 12.605  FALSE #> 47  52 -6.409 -4.722  6.035  FALSE #> 48  53 -7.485 -7.619 20.065  FALSE"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"inspecting-the-target-selection-with-plot_target","dir":"Articles","previous_headings":"Analyzing inventory data with TreeCompR","what":"Inspecting the target selection with plot_target()","title":"Quantifying competition from inventory data","text":"visually inspect position designated target trees relative trees neighbourhood, can use function plot_target(), automatically displays relevant information depending target_source setting target_inv datasets output compete_inv() :  purpose function provide fast tool visual inspection rather create beautiful visual output. data plot contained target_inv object, appealing (e.g., ggplot2-based) visualizations left exercise user.","code":"plot_target(targets4)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"computing-competition-indices-with-compete_inv","dir":"Articles","previous_headings":"Analyzing inventory data with TreeCompR","what":"Computing competition indices with compete_inv()","title":"Quantifying competition from inventory data","text":"compete_inv() flexible input, essence directly accepting everything can also loaded read_inv() also passing additional settings column specifications etc. function, used load data internally. Also options target_source can set define_target() can directly specified compete_inv(), cases function likely called directly unless reasons perform steps explicitly, instance, data structure formatting differ inventory target files inspection target settings desired computing results. target trees already specified target_inv(), outcome can directly passed compete_inv(), ignores target_source argument arguments passed read_inv() define_target(). Otherwise, example possible calculate Hegyi competition index data .csv source non-standard column names decimal field separators (example, German file source) get reasonable target trees via target_source = \"buff_edge\": output function can inspected way using plot_target(CI1) make sure selection target trees make sense.","code":"compete_inv(inv_source = targets4, radius = 10, method = \"CI_Hegyi\") #> ---------------------------------------------------------------------  #> 'compete_inv' class inventory with distance-based competition indices  #> Collection of data for 1 target and 47 edge trees.  #> Source of target trees: buffer around edge    Search radius: 10  #> --------------------------------------------------------------------- #>    id     x      y  dbh CI_Hegyi #> 44 48 0.102 -0.494 24.4     4.39 CI1 <- compete_inv(   inv_source = \"data/inventory5.csv\",   target_source = \"buff_edge\",   radius = 10,    method = \"CI_Hegyi\",   x = Koord_x,    y = Koord_y,   id = Baumname,   dbh = Durchmesser,   sep = \";\",   dec = \",\"   )"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"available-competition-indices","dir":"Articles","previous_headings":"Analyzing inventory data with TreeCompR > Computing competition indices with compete_inv()","what":"Available competition indices","title":"Quantifying competition from inventory data","text":"function computes series inventory-based competition indices commonly used literature can specified via method argument (Hegyi 1974; Braathe, 1980; Rouvinen & Kuuluvainen, 1997; see also Contreras et al., 2011). either based tree diameter breast height (“CI_Hegyi”, “CI_RK1”, “CI_RK2”) tree height (“CI_Braathe”, “CI_RK3”, “CI_RK4”). competition indices computed according following equations, did_i hih_i dbh height neighbor tree ii, dd hh dbh height target tree, distidist_i distance neighbor tree ii target tree. Diameter-based competition indices CI_Hegyi introduced Hegyi (1974): CIHegyi=∑=1ndi/(d⋅disti)CI_{Hegyi} = \\sum_{=1}^{n} d_{} / (d \\cdot dist_{})CI_RK1 according CI1 Rouvinen & Kuuluvainen (1997): CIRK1=∑=1narctan(di/disti)CI_{RK1} = \\sum_{=1}^{n} \\mathrm{arctan}(d_{} / dist_{})CI_RK2 according CI3 Rouvinen & Kuuluvainen (1997): CIRK2=∑=1n(di/d)⋅arctan(di/disti)CI_{RK2} =\\sum_{=1}^{n} (d_{} / d) \\cdot \\mathrm{arctan}(d_{} / dist_{}) Height-based competition indices CI_Braathe according Braathe (1980): CIBraathe=∑=1nhi/(h⋅disti)CI_{Braathe} = \\sum_{=1}^{n} h_{} / (h \\cdot dist_{})CI_RK3 according CI5 Rouvinen & Kuuluvainen (1997): CIRK3=∑=1narctan(hi/disti)CI_{RK3} = \\sum_{=1}^{n} \\mathrm{arctan}(h_{} / dist_{}) trees hi>hh_{} > h CI_RK4 based CI3 Rouvinen & Kuuluvainen (1997) Contreras et al. (2011): CIRK4=∑=1n(hi/h)⋅arctan(hi/disti)CI_{RK4} = \\sum_{=1}^{n} (h_{} / h) \\cdot    \\mathrm{arctan}(h_{} / dist_{}) advantage classical distance-based indices (CI_Hegyi CI_Braathe) clear interpretation sum relative sizes neighbour trees relative target tree size, weighted distance target tree. method = \"all_methods\" (standard setting), compete_inv() computes indices can computed data available inventory.","code":"compete_inv(inv_source = targets4, radius = 10, method = \"all_methods\") #> ---------------------------------------------------------------------  #> 'compete_inv' class inventory with distance-based competition indices  #> Collection of data for 1 target and 47 edge trees.  #> Source of target trees: buffer around edge    Search radius: 10  #> --------------------------------------------------------------------- #>    id     x      y  dbh CI_Hegyi CI_RK1 CI_RK2 #> 44 48 0.102 -0.494 24.4     4.39     33   38.5"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"choosing-a-search-radius","dir":"Articles","previous_headings":"","what":"Choosing a search radius","title":"Quantifying competition from inventory data","text":"indices can calculated compete_inv() based distance-weighted sum relative size neighbor trees within search radius compared size central tree, sum transformation thereof. search radius determines many trees included calculating metric tree, distance-based competition indices extremely sensitive choice search radius. obvious consequence meaningfully possible compare distance based competition indices calculated different search radii. Perhaps less obvious different tree species differ average size rooting patterns, optimal search radius may differ species, comparisons species using competition indices computed settings may always result meaningful results. authors recommend use search radius based average crown size trees plot, Lorimer (1983), propose search radius 3.5 average crown radii. recommendation certainly makes sense sticking standard values like 10 m independent whether calculating competition stunted Elfin forests gigantic Redwood trees, ultimately setting always arbitrary limits comparability indices across studies across species.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-pointcloud.html","id":"pre-process-the-point-clouds","dir":"Articles","previous_headings":"","what":"Pre-process the point clouds","title":"Quantifying competition from point cloud data","text":"using cone cylinder point cloud approaches, trees competition quantified must extracted plot. accurate (time consuming) way manual segmentation, instance CloudCompare. CoudCompare, load point cloud whole plot use Segment function extract target tree. Make sure miss part include neighbouring trees branches, crucial determine parts point cloud belong neighbours points belong target tree. Pay particular attention ground don’t include ground points target tree’s point cloud, otherwise tree’s base position may determined imprecisely later steps tree_pos() function based lowest points point cloud target tree.  extracting target tree, export point cloud selecting file DB Tree click File - Save. whole plot, first clip point cloud area interest. best way select top view use Cross Section function clip point cloud. Make sure target tree edge plot. example dataset paper, used 30 x 30 m plots. exporting/saving point clouds, can select .las/.laz, .txt, .csv, … TreeCompR flexible file formats, possible use format target trees neighbourhoods may slight numeric differences formats complicate coordinate matching. clicking save, asked select output resolution. choose custom resolution coordinate accuracy, make sure choose target tree neighbourhood cloud! examples, rounded coordinates 2 decimal places (.e. 1 cm accuracy), also compete_pc() uses default coordinate matching, values possible.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-pointcloud.html","id":"quantify-competition-with-treecompr","dir":"Articles","previous_headings":"","what":"Quantify Competition with TreeCompR","title":"Quantifying competition from point cloud data","text":"two point clouds target tree neighbourhood, can use read_pc() function TreeCompR read validate , directly pass paths point clouds compete_pc(). compete_pc(), can select method computing competition indices setting comp_method \"cylinder\", \"cone\" \"\". compute competition indices either methods, position center cone cylinder defined. center_position argument allows center cone cylinder either around central point crown projected area (\"crown_pos\") central point tree base (\"base_pos\"). Usually, position tree calculated using lowest points tree take mean median. However, tree growing straight want identify (crown-)competition, think reasonable instead focus center crown. reason, compete_pc() currently defaults center_position = \"crown_pos\", median x y position voxelized crown projected area (see documentation tree_pos() details). want use stem base position, additional parameters can adjust ensure correct position determination, namely h_xy (range m lowermost point tree point cloud base position calculated ) z_min (minimum number points lowermost layer voxels used calculate base position tree). methods settings sensitivity can found Seidel et al. (2015), Metz et al. (2013), , original KKL index, Pretzsch et al. (2002). following example, compete_pc used calculate cone cylinder-based competition indices centered around crown center, cone opening height 0.6 times total target tree height cylinder radius 4 m: result object type compete_pc, .e. modified data.frame can save use statistical analysis. contains name ID (filename) tree, height, type center_position used, computed competition index value(s) (voxel counts) settings parameters controlling cylinder cone size. want use neighbourhood one target tree within plot, need read point cloud file time. Instead, simply read read_pc() use . can also load target tree outside compete_pc() function. Internally, compete_pc() crops neighbourhood immediate surroundings cone cylinder matching neighbour tree point clouds large neighbourhoods far computationally expensive step, neighbourhood loaded filtering (done efficiently using functions data.table package) comparably fast. speed coordinate matching, done integer coordinates rounded digit accuracy specified acc_digits, defaults 2 (round cm). accurate data, can consider increasing value, though slow computations likely large impact outcome competition indices computed coarser spatial scale (default 0.1 m). Since loading large point cloud memory considerable computational overhead can take lot time (especially older hard drives), loading neighbourhood just can speed analysis considerably batch processing large number trees even neighbourhood large. objects become large handle within memory, recommend split outside R data preparation step.","code":"library(TreeCompR)  compete_pc(forest_source = \"../tests/testthat/testdata/neighborhood.txt\",                  tree_source = \"../tests/testthat/testdata/tree.txt\",                  comp_method = \"both\", # calculate CI in cylinder and cone                 center_position = \"crown_pos\", # center for cone and cylinder                 cyl_r = 4, # radius in m                 h_cone = 0.6, # position where the cone starts to open relative                 # to the height of the target tree (0.6 = 60 % of tree height)                 print_progress = \"some\" # controls how much of the progress is                 )                       # printed #> ----- Processing competition indices for: tree ----- #> Cone-based CI = 16046      Cylinder-based CI = 56820 #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cone h_cone CI_cyl cyl_r #> 1   tree          22.8    crown center   16046    0.6  56820     4 neighbours <- read_pc(\"../tests/testthat/testdata/neighborhood.txt\") #> No named coordinates. Columns V1, V2, V3 (no.  1, 2, 3 in raw data) #> used as x, y, z coordinates, respectively.  tree <- read_pc(\"../tests/testthat/testdata/tree.txt\") #> No named coordinates. Columns V1, V2, V3 (no.  1, 2, 3 in raw data) #> used as x, y, z coordinates, respectively.  compete_pc(forest_source = neighbours,                  tree_source = tree,                  comp_method = \"both\", # calculate CI in cylinder and cone                 center_position = \"crown_pos\", #center for cone and cylinder                 cyl_r = 4, #radius in m                 h_cone = 0.6, #set height where the cone starts                  #to open in relation to tree height (0.6 = 60 % of tree height)                 print_progress = \"full\" #get full information during processing                 ) #> ----- Processing competition indices for: tree ----- #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cone h_cone CI_cyl cyl_r #> 1   tree          22.8    crown center   16046    0.6  56820     4 #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cone h_cone CI_cyl cyl_r #> 1   tree          22.8    crown center   16046    0.6  56820     4"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-pointcloud.html","id":"example-for-batch-processing","dir":"Articles","previous_headings":"","what":"Example for batch-processing","title":"Quantifying competition from point cloud data","text":"study consists many target trees surrounding plots, may useful create lookup table efficiently run function trees. example lookup table might look like: case, lookup table contains one path segmented target tree point cloud, another path corresponding 30 x 30 m² neighbourhood. can use dplyr::mutate() append function arguments compete_pc(), purr::pmap() map paths settings line line use compete_pc() settings specified . can take considerable amount time processing hundreds trees, different options print_progress can useful able keep track analysis interrupt time something goes wrong.","code":"# Define the base paths neighborhood_path <- \"/path/to/neighborhood/\" trees_path <- \"/path/to/trees/\"  # List files in the neighborhood and tree folders neighborhood_files <- list.files(neighborhood_path, full.names = TRUE,                                   pattern = \"\\\\.las$\") tree_files <- list.files(trees_path, full.names = TRUE, pattern = \"\\\\.las$\")  # Create TreeIDs if needed # Assuming the same number of neighborhood and tree files,  #and each tree has a corresponding neighborhood file TreeIDs <- paste0(\"Tree_\", seq_along(neighborhood_files))  # Create the lookup table as a data frame lookup_table <- data.frame(   TreeID = TreeIDs,   forest_source = neighborhood_files,   tree_source = tree_files,   stringsAsFactors = FALSE ) # Print the lookup table print(lookup_table) #>   TreeID                            forest_source               tree_source #> 1 Tree_1 /path/to/neighborhood/neighborhood_1.las /path/to/trees/tree_1.las #> 2 Tree_2 /path/to/neighborhood/neighborhood_2.las /path/to/trees/tree_2.las #> 3 Tree_3 /path/to/neighborhood/neighborhood_3.las /path/to/trees/tree_3.las #> 4 Tree_4 /path/to/neighborhood/neighborhood_4.las /path/to/trees/tree_4.las #> 5 Tree_5 /path/to/neighborhood/neighborhood_5.las /path/to/trees/tree_5.las #calculate both methods at the same time library(dplyr) lookup <- lookup_table %>% dplyr::select(forest_source, tree_source) #define parameter settings within the lookup table lookup_cone50_cyl5 <- lookup %>% dplyr::mutate(comp_method = \"both\",                                                 center_position = \"crown_pos\",                                                 cyl_r = 5, h_cone = 0.5,                                                 z_min = 100, h_xy = 0.3,                                                 print_progress = \"some\") #use pmap (alternative to lapply) to loop over your table results <- lookup_cone50_cyl5 %>% purrr::pmap(compete_pc) %>% dplyr::bind_rows()"},{"path":"https://juliarieder.github.io/TreeCompR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Julia S. Rieder. Author, maintainer. Roman M. Link. Author.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rieder J, Link RM, Köthe K, Seidel D, Ullmann T, Žmegač , Zang C, Schuldt B (2024). “TreeCompR: Tree competition indices inventory data 3D point clouds.” BiorXiv. doi:10.1101/2024.03.23.586379.","code":"@Article{,   title = {TreeCompR: Tree competition indices for inventory data and 3D point clouds},   author = {J.S. Rieder and R. M. Link and K. Köthe and D. Seidel and T. Ullmann and A. Žmegač and C. Zang and B. Schuldt},   journal = {BiorXiv},   year = {2024},   doi = {10.1101/2024.03.23.586379}, }"},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"treecompr","dir":"","previous_headings":"","what":"Tree Competition Indices For Inventory Data And 3D Point Clouds","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"R Package calculating distance-dependent point cloud-based individual tree competition indices R package designed quantitative analysis individual tree competition within forest ecosystems. accepts inputs LiDAR point clouds (dataframe xyz columns las/laz files) forest plots individual target trees, inventory tables (including tree ID, x, y, dbh /h). use various competition indices, enables assessment measurement competition trees, providing valuable insights forest ecology, inventories, forest management strategies. package facilitates systematic approach understanding interactions resource competition among trees enables informed decision making forest management.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"can install development version TreeCompR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"juliarieder/TreeCompR\", dependencies = TRUE)  # or with vignettes on your computer devtools::install_github(\"juliarieder/TreeCompR\",              dependencies = TRUE, build_vignettes = TRUE)"},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"TreeCompR can read point clouds inventory tables quantifies tree competition different ways: compete_pc() quantifies tree competition point clouds using cone cylinder method (see Metz et al. 2013;Seidel et al. 2015) read_pc() reads 3D point clouds .las/.laz files, .ply files text-file formats .txt .csv, converts LAS objects data.frames TreeCompR compatible format tree_pos() computes base position height target tree point clouds compete_inv() quantifies size- distance-dependent competition using inventory data based series published indices read_inv() reads validates inventory tables data.frames, reads tabular data directly text-file sources .txt .csv define_target() can used define trees within plot competition quantified compete_inv() plot_target() check validate tree position(s) surrounding trees defining define_target()","code":""},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get started","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"look examples check package can Get started.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"workflows-and-tutorials","dir":"","previous_headings":"","what":"Workflows and Tutorials","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"ALS workflow learn pre-process use ALS data (airborne laser scanning) derive size-distance-based competition indices TLS workflow learn pre-process use TLS/MLS data (terrestrial mobile laser scanning) derive size-distance-based competition indices Point-cloud-based approach Overview quantifying competition directly point clouds ground-based laser scans pre-process data cone cylinder method","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/TreeCompR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds — TreeCompR-package","title":"TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds — TreeCompR-package","text":"Quantify individual tree competition using inventory data point clouds.","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/TreeCompR-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds — TreeCompR-package","text":"Maintainer: Julia S. Rieder julia.rieder@uni-wuerzburg.de (ORCID) Authors: Roman M. Link roman.link@plant-ecology.de (ORCID)","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify size- and distance-dependent competition using inventory data — compete_inv","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"compete_inv() computes one several distance-height- distance-dbh-dependent competition indices based forest inventory data.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"","code":"compete_inv(   inv_source,   target_source = \"buff_edge\",   radius,   method = c(\"all_methods\", \"CI_Hegyi\", \"CI_Braathe\", \"CI_RK1\", \"CI_RK2\", \"CI_RK3\",     \"CI_RK4\"),   x = NULL,   y = NULL,   dbh = NULL,   height = NULL,   id = NULL,   dbh_unit = c(\"cm\", \"m\", \"mm\"),   height_unit = c(\"m\", \"cm\", \"mm\"),   verbose = TRUE,   tol = 1,   crop_to_target = FALSE,   ... )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"inv_source either object class target_inv, object can imported read_inv() (case, x, y, id, dbh, /height can specified function – see corresponding documentation details). provided target_inv object, function ignores target_source overrides arguments passed read_inv() define_target(). target_source one following: path object can imported read_inv() (case, column specifications inv_source - possible, load outside compete_inv()). vector class \"character\" containing tree IDs identifying target trees  format id column inv, vector class logical specifying row inv whether corresponding tree target tree, another object class forest_inv containing coordinates target trees. case, coordinates matched coordinates inv IDs may differ (useful e.g. target trees defined based GPS coordinates matched airborne laser scanning dataset). character vector length 1 defining method target trees determined. Allowed \"buff_edge\" excluding trees least one search radius forest edge, \"exclude_edge\" excluding edge trees \"all_trees\" including trees dataset (hardly ever good idea unless trees entire forest dataset). standard \"buff_edge\". See define_target() details. radius numeric length 1. Search radius (m) around target tree. neighboring trees within radius classified competitors. method character string assigning method quantifying competition. dbh-distance-dependent methods \"CI_Hegyi\", \"CI_RK1\", \"CI_RK2\". Height-distance-dependent methods \"CI_Braathe\", \"CI_RK3\", \"CI_RK4\". \"all_methods\" can specified compute indices can calculated available data. x character length 1 name variable inv_source containing x coordinates tree m. NULL (default), function tries identify x coordinate data. y character length 1 name variable inv_source containing y coordinates tree meters. NULL (default), function tries identify y coordinate data. dbh character length 1 name variable inv_source containing diameter breast height tree (default cm, can defined via dbh_unit). NULL (default), function tries identify dbh data. height character length 1 name variable inv_source containing height tree (default m,   can defined via heigh_unit). NULL (default), function tries identify height data. id character length 1 name variable inv_source containing unique tree ID. NULL (default), function tries identify ID data. possible, trees assigned unique number. IDs coerced character. dbh_unit character length 1. Unit diameter measurements (one \"cm\", \"m\" \"mm\". defaults \"cm\"). height_unit character length 1. Unit diameter measurements (one \"m\", \"cm\" \"mm\". defaults \"m\"). verbose logical length 1. information progress printed? Defaults TRUE. tol numeric length 1. Tolerance match tree coordinates. coordinates measured field GPS, inv_source contains x y coordinates larger number trees obtained segmentation, tolerance matching forest inventory target tree positions. forest tree within tolerance target tree, competition indices calculated tree function return warning. tol defaults 1 m, chosen depending measurement accuracy GPS coordinates. crop_to_target logical length 1. inventory limited extent target coordinates? TRUE, extent inv cropped extent forest_inv \\(\\pm\\) radius + tol reduce computational load later steps. Defaults FALSE. ... additional arguments passed data.table::fread().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"object classcompete_inv: modified data.table position size designated target tree(s) one competition indices depending chosen method(s).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"compete_inv() calculates one several distance-dependent tree competition indices based forest inventory data. can obtained either classical forest inventory methods, derived LiDAR point clouds (see ). Inventory data can either loaded source, imported object inheriting class data.frame (.e., data.frames, tibbles, data.table objects etc.) forest_inv type object created read_inv(). compete_inv() takes arguments reading inventory data flexibility read_inv(). compute competition indices trees inventory dataset, necessary decide target trees analysis. also possible calculate competition indices trees inventory, almost never good idea unless dataset covers trees entire forest, intense edge effects trees edge spatial extent dataset. compete_inv() allows define target trees number different ways based function define_target() called internally.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"available-competition-indices","dir":"Reference","previous_headings":"","what":"Available competition indices","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"competition indices computed according following equations, \\(d_i\\) \\(h_i\\) dbh height neighbor tree \\(\\), \\(d\\) \\(h\\) dbh height target tree, \\(dist_i\\) distance neighbor tree \\(\\) target tree. Diameter-based competition indices CI_Hegyi introduced Hegyi (1974):  \\(CI_{Hegyi} = \\sum_{=1}^{n} d_{} / (d \\cdot dist_{})\\) CI_RK1 according CI1 Rouvinen & Kuuluvainen (1997): \\(CI_{RK1} = \\sum_{=1}^{n} \\mathrm{arctan}(d_{} / dist_{})\\) CI_RK2 according CI3 Rouvinen & Kuuluvainen (1997):  \\(CI_{RK2} =\\sum_{=1}^{n} (d_{} / d) \\cdot \\mathrm{arctan}(d_{}    / dist_{})\\) Height-based competition indices CI_Braathe according Braathe (1980):  \\(CI_{Braathe} = \\sum_{=1}^{n} h_{} / (h \\cdot dist_{})\\) CI_RK3 according CI5 Rouvinen & Kuuluvainen (1997):  \\(CI_{RK3} = \\sum_{=1}^{n} \\mathrm{arctan}(h_{} / dist_{})\\) trees \\(h_{} > h\\) CI_RK4 based CI3 Rouvinen & Kuuluvainen (1997) Contreras et al. (2011):  \\(CI_{RK4} = \\sum_{=1}^{n} (h_{} / h) \\cdot    \\mathrm{arctan}(h_{} / dist_{})\\) indices distance-weighted sums relative size competitor trees within search radius compared target tree (sum transformations thereof), sensitive choice search radius. generally possible meaningfully compare competition indices computed different search radii. distance competitors affect growth central tree certainly specific likely also depends average size trees species target tree far roots spread local conditions. Lorimer (1983) recommends use 3.5 times mean crown radius target trees, likely single value works well conditions, possible values competition indices calculated radius different meanings different species.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"tree-segmentation","dir":"Reference","previous_headings":"","what":"Tree Segmentation","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"Various approaches can used segment (airborne) laser scanning point clouds single trees obtain inventory data based . Existing R packages example: TreeLS package automated segmentation terrestrial/mobile laser scans lidR package different options segment point cloud Canopy Height Model (CHM) itcLiDARallo() package itcSegment careful low resolution/low density point clouds, oversegmentation trees usually issue! examples workflows obtain inventory dator airborne laser scanning data terrestrial/mobile laser scanning data, see ALS workflow TLS workflow, respectively.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"literature","dir":"Reference","previous_headings":"","what":"Literature","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"Hegyi, F., 1974. simulation model managing jackpine stands. : Fries, J. (Ed.), Proceedings IUFRO meeting S4.01.04 Growth models tree stand simulation, Royal College Forestry, Stockholm. Braathe, P., 1980. Height increment young single trees relation height distance neighboring trees. Mitt. Forstl. VersAnst. 130, 43–48. Rouvinen, S., Kuuluvainen, T., 1997. Structure asymmetry tree crowns relation local competition natural mature Scot pine forest. Can. J. . Res. 27, 890–902. Contreras, M.., Affleck, D. & Chung, W., 2011. Evaluating tree competition indices predictors basal area increment western Montana forests. Forest Ecology Management, 262(11): 1939-1949. Lorimer, C.G., 1983. Tests age-independent competition indices individual trees natural hardwood stands. . Ecol. Manage. 6, 343–360.","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"","code":"if (FALSE) { # \\dontrun{ # Quantify the Hegyi index for specified target trees with search radius 10m CI <- compete_inv(\"path/to/invtable.csv\",   \"path/to/target_trees.csv\", radius = 10, method = \"CI_Hegyi\") # Quantify the Braathe index for specified target trees with search radius #10m and adjust CI <- compete_inv(\"path/to/invtable.csv\",   \"path/to/target_trees.csv\", radius = 10, method = \"CI_Braathe\") # Specify the units of dbh or height of your input data CI <- compete_inv(\"path/to/invtable.csv\",   \"path/to/target_trees.csv\", radius = 10, method = \"CI_Hegyi\",   dbh_unit = \"m\", height_unit = \"m\") # Quantify all available indices for all trees within the plot that are one #search radius away from plot edge CI <- compete_inv(\"path/to/invtable.csv\", target_source = \"buff_edge\",         radius = 12, method = \"all_methods\") } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify tree competition from point clouds — compete_pc","title":"Quantify tree competition from point clouds — compete_pc","text":"Counts voxels neighboring trees intersect search cone search cylinder around target tree according Seidel et al. (2015) Metz et al. (2013).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify tree competition from point clouds — compete_pc","text":"","code":"compete_pc(   forest_source,   tree_source,   comp_method = c(\"cone\", \"cylinder\", \"both\"),   center_position = c(\"crown_pos\", \"base_pos\"),   tree_name = NULL,   cyl_r = 5,   h_cone = 0.6,   z_min = 100,   h_xy = 0.3,   acc_digits = 2,   res = 0.1,   print_progress = c(\"some\", \"full\", \"none\"),   override_pos_check = FALSE,   ... )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify tree competition from point clouds — compete_pc","text":"forest_source path file neighborhood point cloud data.frame LAS object (see lidR::LAS) point cloud data passed read_pc(), object class forest_pc created read_pc(). neighborhood can, include target tree , height normalized, can include ground points. Coordinates Cartesian coordinate system m. paths source files, supported formats .las, .laz, .ply well formats accepted data.table::fread() (.csv, .txt, others). tree_source path file point cloud segmented target, tree data.frame LAS object (see lidR::LAS) point cloud data passed read_pc(), object class forest_pc created read_pc(). Coordinates coordinate system forest_source. paths source files, supported formats .las, .laz, .ply formats accepted data.table::fread(). comp_method character string length 1 competition method. Allowed values \"cone\" cone method, \"cylinder\" cylinder method \"\" methods. Default cone method. See details computation. center_position character string length 1 position used center search cone/cylinder. Allowed values \"crown_pos\" central point crown projected area \"base_pos\" stem base position computed tree_pos(). Default value \"crown_pos\". tree_name (optional) ID tree. argument put, defaults name argument provided tree_source. cyl_r (optional) needed using comp_method \"cylinder\"; numeric value cylinder radius m. Default 5 m. h_cone (optional) using comp_method \"cone\"; numeric value describing fraction height tree tip search cone located. example, values 0.5 0.6 specify cone opens 50 60 % target tree's height, respectively. Default 0.6 proposed Seidel et al. (2015). z_min integer length 1 describing minimum number points needed lowermost 1 voxel depth Z layer consider part target tree. Default 100. changing voxel resolution (res) default value 0.1, different settings may necessary.  Used calculate stem base position target tree. details see tree_pos(). h_xy numeric length 1 describing height range m stem base x y positions used calculate x y coordinates stem base target tree. Default 0.3 m. Used calculate stem base position target tree. details see tree_pos(). acc_digits integer length 1 defining number digits accuracy point cloud measurements. Data rounded internally value speed calculations avoid problems joining tree neighborhood data resulting numeric accuracy. Defaults 2 (round 2 digits decimal point). res numeric length 1 defining resolution voxel passed VoxR::vox(). Defaults 0.1 (10 cm voxel size). change good reasons standard used Seidel et al. (2015) papers results strongly scale dependent! print_progress character length 1. Allowed values \"full\" (print progress full output), \"\" (print main details) \"none\" (print progress). Defaults \"\". override_pos_check logical: function test target tree actually situated within neighborhood? Defaults FALSE. change good reasons , e.g., computing competition tree situated edge forest stand. ... additional arguments passed data.table::fread().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify tree competition from point clouds — compete_pc","text":"object type compete_pc: modified data.frame tree ID, tree height, type center position used computation well counts number voxels neighborhood point cloud reach cone/cylinder spanned /around target tree.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantify tree competition from point clouds — compete_pc","text":"compete_pc() computes competition indices based voxel counts neighbor trees intersect search cone search cylinder around target tree. cases, function read_pc() called internally able automatically identify columns coordinates point clouds provided non-standard file types. case, possible provide arguments pass function, load datasets separately custom settings read_pc() loading external functions pass compete_pc() kind object inheriting data.frame (base R data.frames, tibbles, data.tables etc).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"cone-method","dir":"Reference","previous_headings":"","what":"Cone Method","title":"Quantify tree competition from point clouds — compete_pc","text":"Based search cone opening angle 60 degrees, default opening basal point situated 60 % height target tree. competition index defined number voxels neighboring trees  (default, 0.1 m res.) situated within cone spanned around target tree (cf. Metz et al 2013; Seidel et al., 2015). standard value h_cone = 0.6 can adjusted, instance neighbor trees intersect cone target tree. However, careful adjusting parameter, competition indices computed different h_cone easily compared among .","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"cylinder-method","dir":"Reference","previous_headings":"","what":"Cylinder Method","title":"Quantify tree competition from point clouds — compete_pc","text":"Based  search cylinder pre-defined radius cyl_r around target tree (5 m default). competition index defined number voxels neighboring trees  (default, 0.1 m res.) situated within cylinder around target tree (cf. Seidel et al., 2015). index sensitive choice cylinder radius, careful comparing competition indices computed different values cyl_r. indices highly sensitive voxel resolution, recommended change res default value 0.1 (.e., 10 cm voxel size) unless good reasons . calculating competition indices single trees accompanying point cloud immediate neighborhood, using file paths datasets tree_source / neighbor_source computationally efficient. However, calculating indices several trees belonging neighborhood, may faster load neighborhood outside compete_pc() single time using read_pc() passing compete_pc() forest_pc object reduces computational overhead due loading point cloud memory. cases, may also make sense load process forest point cloud LAS object (see lidR::LAS) process outside TreeCompR analysis. source files large, may still lead memory problems especially machines low RAM capacity. cases, may make sense split data set smaller chunks outside R reduce memory load.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"note-support-of-las-laz-and-ply-formats","dir":"Reference","previous_headings":"","what":"Note: support of .las, .laz and .ply formats","title":"Quantify tree competition from point clouds — compete_pc","text":"lidR package installed able read .las/.laz files, internally processed lidR::readTLSLAS(). Analogously, point clouds .ply format, Rvcg package required loaded Rvcg::vcgPlyRead().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"literature","dir":"Reference","previous_headings":"","what":"Literature","title":"Quantify tree competition from point clouds — compete_pc","text":"Metz, J., Seidel, D., Schall, P., Scheffer, D., Schulze, E.-D. & Ammer, C. (2013). Crown modeling terrestrial laser scanning approach assess effect aboveground intra- interspecific competition tree growth. Forest Ecology Management,310:275-288. https://doi.org/10.1016/j.foreco.2013.08.014 Pretzsch, H., Biber, P. & Dursky, J. (2002). single tree-based stand simulator SILVA: construction, application evaluation. . Ecol. Manage. 162, 3-21. https://doi.org/10.1016/S0378-1127(02)00047-6 Seidel, D., Hoffmann, N., Ehbrecht, M., Juchheim, J. & Ammer, C. (2015). neighborhood affects tree diameter increment - New insights terrestrial laser scanning methodical considerations. Forest Ecology Management, 336: 119-128. http://dx.doi.org/10.1016/j.foreco.2014.10.020","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify tree competition from point clouds — compete_pc","text":"","code":"if (FALSE) { # \\dontrun{ # Due to the large required datasets it is not possible to provide running # examples, but we hope that these example uses are helpful  # Quantifying crown competition for a single tree using the cone method CI_cone <- compete_pc(\"path/to/forest_pc.las\", \"path/to/tree_pc.las\",                           \"cone\", h_cone = 0.5)  # Competition for a single tree using the cylinder method with 4 m radius CI_cyl <- compete_pc(\"path/to/forest_pc.ply\", \"path/to/tree_pc.ply\", \"cylinder\", cyl_r = 4)  # Quantifying competition for a single tree using both methods CI_cyl <- compete_pc(\"path/to/forest_pc.txt\", \"path/to/tree_pc.txt\", \"cylinder\", cyl_r = 4, h_cone = 0.6)  # Loading a large neighborhood outside compete_pc() to reuse the data for # several target trees  # load neighborhood neigh <- read_pc(\"path/to/forest_pc.las\")  # get paths to trees tree_paths <- list.files(\"folder_with_trees/\")  # map over paths to get competition indices for all trees library(tidyverse) # for purrr() and bind_rows() CI_data <- map(   tree_paths,   ~compete_pc(       forest_source = neigh,       tree_source = file.path(\"folder_with_trees\", .x),       tree_name = .x,       method = \"cone\"       )     ) %>%     bind_rows() } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":null,"dir":"Reference","previous_headings":"","what":"Define target trees in forest inventory data — define_target","title":"Define target trees in forest inventory data — define_target","text":"define_target() takes forest_inv dataset returns updated forest inventory highlighted target trees analysis compete_inv. Target trees can manually specified tree ID, imported different dataset identified automatically excluding edge trees coordinates.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define target trees in forest inventory data — define_target","text":"","code":"define_target(   inv,   target_source = \"buff_edge\",   radius = 10,   tol = 1,   crop_to_target = FALSE,   verbose = TRUE )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define target trees in forest inventory data — define_target","text":"inv object class forest_inv created read_inv(). target_source one following: vector class \"character\" containing tree IDs identifying target trees  format id column inv. vector class logical specifying row inv whether corresponding tree target tree. another object class forest_inv containing coordinates target trees. case, coordinates matched coordinates inv IDs may differ (useful e.g. target trees defined based GPS coordinates matched airborne laser scanning dataset). character vector length 1 defining method target trees determined. Allowed \"buff_edge\" excluding trees least one search radius forest edge, \"exclude_edge\" excluding edge trees \"all_trees\" including trees dataset (hardly ever good idea unless trees entire forest dataset). standard \"buff_edge\". See details. radius numeric length 1, Search radius (m) around target tree wherein neighboring trees classified competitors. used target_source \"buff_edge\", \"exclude_edge\" type forest_inv. Defaults 10. tol numeric. used target_source inventory second set coordinates. Tolerance match tree coordinates forest inventory target datasets specified second set coordinates. field measurements (e.g. based GPS) used identify target trees full inventory different data source (e.g. ALS data), higher tolerance value may required identify trees depending measurement accuracy. Values 0 mean exact matching. Defaults 1 (match within 1 m buffer). crop_to_target logical length 1. inventory limited extent target coordinates? TRUE, extent inv cropped extent forest_inv \\(\\pm\\) radius + tol reduce computational load later steps. Defaults FALSE. verbose logical length 1. information progress printed? Defaults TRUE.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define target trees in forest inventory data — define_target","text":"object class target_inv (inherits forest_inv): modified data.table x y coordinates tree, unique tree identifier (id), least one tree diameter breast height (dbh, cm) tree height (height,m) new logical column target specifying whether tree defined target tree.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define target trees in forest inventory data — define_target","text":"define_target() can used select target trees forest_inv object either manually specifying character vector tree IDs, logical vector specifies tree inventory whether treated target tree, separate set (approximate) coordinates target trees matched original inventory, character string describing choose target trees based spatial arrangement. target defined second set coordinates, coordinates matched inventory data. IDs ignored case  matching based closest trees buffer tol m  (default tol = 1: matching within 1 m). size-related variables second set coordinates ignored well make sure later steps competition indices computed data data source. different target trees matched tree inventory, two trees inventory distance target tree within 5 cm, function fails error. two inventory trees within specified tolerance difference larger, function proceeds warning. intended use case determining target trees way compute tree competition ALS data based GPS coordinates single trees studies based single tree rather plot-level data, creates need different data sources compute competition. methods target_source = \"buff_edge\" target_source = \"exclude_edge\" intended cases desired compute valid competition indices many trees possible avoiding edge effects. possible designate trees dataset target tree setting target_source = \"all_trees\", good idea majority cases: unless dataset contains trees forest (possible ALS-based data, unlikely data based classical inventory methods TLS/MLS), extreme edge effects outer edge extent covered trees resulting strongly underestimated competition edge trees. target_source = \"buff_edge\" excludes trees less one search radius (radius) away plot border (approximated concave hull based concaveman::concaveman()) hence guarantees include trees can obtain valid competition index values search radius. target_source = \"exclude_edge\" removes edge trees hence less restrictive, prone edge effects. use target_source = \"all_trees\" unless know exactly !","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define target trees in forest inventory data — define_target","text":"","code":"if (FALSE) { # \\dontrun{ # read inventory inv <- read_inv(\"path/to/invtable.csv\") #or just validate your already loaded inventory data #e.g.extracted from lidR package inv <- read_inv(inventory, height = Z, height_unit = \"m\") # or from itcSegment (itcLiDARallo) inv <- read_inv(inventory, height = Height_m, height_unit = \"m\") # target trees defined by a buffer around the plot edges target <- define_target(inv, target_source = \"buff_edge\", radius = 10) #or if your trees are definitely at a forest edge #(and not just at the edge of your dataset) you can include all trees target <- define_target(inv, target_source = \"all_trees\", radius = 10) } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot selection of target trees — plot_target","title":"Plot selection of target trees — plot_target","text":"plot_target() can used  target_inv dataset output compete_inv function inspect spatial positions target trees.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot selection of target trees — plot_target","text":"","code":"plot_target(inv, radius = NULL)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot selection of target trees — plot_target","text":"inv object class compete_inv target_inv. radius numeric length 1, Search radius (m) around target tree wherein neighboring trees classified competitors. needed target_inv objects methods radius dependent (.e., cases target_source defined character logical vector cases target_source = \"all_trees\").","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot selection of target trees — plot_target","text":"plot spatial arrangement target trees.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot selection of target trees — plot_target","text":"function creates plot trees forest inventory dataset target trees surrounding search radii highlighted. created target_source = \"buff_edge\" target_source = \"exclude_edge\", estimated plot margin (, case \"buff_edge\", also buffer margin) added polygon. function meant visual inspection tool checking validity choice target trees.","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot selection of target trees — plot_target","text":"","code":"if (FALSE) { # \\dontrun{   # plot neighborhood for existing inventory   comp <- compete_inv(inv, \"buff_edge\", radius = 10)   plot_target(comp) } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":null,"dir":"Reference","previous_headings":"","what":"Read forest inventory data — read_inv","title":"Read forest inventory data — read_inv","text":"Read inventory table sourced file path object inherits class data.frame.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read forest inventory data — read_inv","text":"","code":"read_inv(   inv_source,   x = NULL,   y = NULL,   dbh = NULL,   height = NULL,   id = NULL,   dbh_unit = c(\"cm\", \"m\", \"mm\"),   height_unit = c(\"m\", \"cm\", \"mm\"),   verbose = TRUE,   names_as_is = FALSE,   ... )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read forest inventory data — read_inv","text":"inv_source object inherits class data.frame, character path file file format readable data.table::fread(). provided forest inventory data data.frame, structure column names validated homogenized; else, function tries read dataset specified path. x character length 1 name variable inv_source containing x coordinates tree m. NULL (default), function tries identify x coordinate data. y character length 1 name variable inv_source containing y coordinates tree meters. NULL (default), function tries identify y coordinate data. dbh character length 1 name variable inv_source containing diameter breast height tree (default cm, can defined via dbh_unit). NULL (default), function tries identify dbh data. height character length 1 name variable inv_source containing height tree (default m,   can defined via heigh_unit). NULL (default), function tries identify height data. id character length 1 name variable inv_source containing unique tree ID. NULL (default), function tries identify ID data. possible, trees assigned unique number. IDs coerced character. dbh_unit character length 1. Unit diameter measurements (one \"cm\", \"m\" \"mm\". defaults \"cm\"). height_unit character length 1. Unit diameter measurements (one \"m\", \"cm\" \"mm\". defaults \"m\"). verbose logical length 1. information progress printed? Defaults TRUE. names_as_is logical length 1. TRUE, NULL characters excepted column names x, y, dbh, height id, column names internally substituted. Defaults FALSE, normally right choice interactive use (TRUE needed use within functions). ... additional arguments passed data.table::fread()","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read forest inventory data — read_inv","text":"object class forest_inv: modified data.table x y coordinates tree, unique tree identifier (id) tree diameter breast height (dbh, cm) tree height (height, m) available.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read forest inventory data — read_inv","text":"Function reading validating forest inventory data. Supports formats readable data.table::fread(). provided tabular data without explicitly specified variable names, function default takes columns named \"X\" \"Y\" (\"x\" \"y\") tree coordinates, looks columns named \"height\", \"height_m\" \"h\" well \"dbh\", \"diameter\",\"diam\", \"d\" (capitalization) size-related variables. tree ids taken columns named \"id\", \"tree_id\", \"treeID\" \"tree.id\" (capitalization). special characters besides \".\" \"_\" stripped column names matching. columns coordinates can identified, function fails error. ID column available, function assigns unique number tree (note make specifying custom target trees difficult). possible read datasets without dbh height, usually sensible used accessory datasets identifying target trees (e.g. target trees identified taking GPS coordinates manually field).","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read forest inventory data — read_inv","text":"","code":"if (FALSE) { # \\dontrun{ # prepare inventory table for compete_inv() inv <- fread(path = \"path/to/table.csv\") #specify the units of parameters within your input inv_table <- read_inv(inv, dbh_unit = \"cm\", height_unit = \"m\") # Read inventory table directly from directory inv_table <- read_inv(inv_source = \"path/to/table.csv\", dbh_unit = \"cm\", height_unit = \"m\") } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Read trees and neighborhoods from point cloud data. — read_pc","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"Read validate point cloud sourced file stored disk, object inherits class data.frame, LAS object lidR package (lidR::LAS). Supported file formats .las, .laz, .ply well formats accepted data.table::fread() (.csv, .txt, others).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"","code":"read_pc(pc_source, verbose = TRUE, xlim = NULL, ylim = NULL, zlim = NULL, ...)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"pc_source object inherits class data.frame,  LAS object, character string path point cloud individual tree whole plot either .las/.laz .ply format, file format readable data.table::fread(). provided point cloud object data.frame, structure column names validated homogenized; else, function tries read point cloud specified path. verbose logical length 1. information progress printed? Defaults TRUE. xlim (optional) numeric vector defining range x coordinates. Can vector length 2 minimum maximum x value, vector arbitrary length (case base::range() used constrain x values range). can useful memory-efficient handling large point cloud objects. Defaults NULL (use full range x coordinates). ylim (optional) numeric vector defining range y coordinates. Can vector length 2 minimum maximum y value, vector arbitrary length (case base::range() used constrain y values range). can useful memory-efficient handling large point cloud objects. Defaults NULL (use full range y coordinates). zlim (optional) numeric vector defining range z coordinates. Can vector length 2 minimum maximum z value, vector arbitrary length (case base::range() used constrain z values range). can useful memory-efficient handling large point cloud objects. Defaults NULL (use full range z coordinates). ... additional arguments passed data.table::fread()","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"object class forest_pc (inherits data.table) x, y z coordinates tree forest point cloud.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"Function reading validating point cloud data. Currently, supported file formats .las, .laz, .ply, well formats accepted data.table::fread(). formats, please load point cloud data separately enter coordinates data.frame. provided tabular data (either data.frame via path data.table::fread() readable source), function default takes columns named \"X\", \"Y\", \"Z\" \"x\", \"y\", \"z\" coordinate vectors. columns matching names available, takes first three numeric columns returns message. dataset contain three numeric columns one columns labeled x, y, z numeric, function fails error. xlim, ylim zlim arguments used internally compete_pc() filter neighborhood dataset relevant range around target tree speed calculations.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"note-support-of-las-laz-and-ply-formats","dir":"Reference","previous_headings":"","what":"Note: support of .las, .laz and .ply formats","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"lidR package installed able read .las/.laz files, internally processed lidR::readTLSLAS(). Analogously, point clouds .ply format, Rvcg package required loaded Rvcg::vcgPlyRead().","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"","code":"if (FALSE) { # \\dontrun{ # Read a tree point cloud in las or laz format tree <- read_pc(pc_source = \"path/to/tree_point_cloud.las\")  # Read a tree point cloud in ply format tree <- read_pc(pc_source = \"path/to/tree_point_cloud.ply\")  # Read a tree point cloud in txt format tree <- read_pc(pc_source = \"path/to/tree_point_cloud.txt\")  # Read a tree point cloud in csv format with non-standard separators tree <- read_pc(pc_source = \"path/to/tree_point_cloud.txt\",   dec = \",\", sep = \";\")  # Read a forest point cloud in a specified range around a target tree of # known position (+- 5 m around the origin) neighborhood <- read_pc(pc_source = \"path/to/forest_point_cloud.las\",   xlim = c(-5, 5), ylim = c(-5, 5))  # Convert a point cloud already loaded as a data.frame into forest_pc format tree <- read_pc(tree_df)  } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":null,"dir":"Reference","previous_headings":"","what":"Position and Height of a Tree from Point Cloud — tree_pos","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"Compute stem base position, metroid crown projected area stem height tree","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"","code":"tree_pos(tree, z_min = 100L, h_xy = 0.3, res = 0.1, tree_name = NULL)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"tree tree_pc data.frame (x, y, z) tree point cloud. Coordinates metric system! z_min integer length 1 describing minimum number points needed lowermost 1 voxel depth Z layer consider part tree. Default 100. changing voxel resolution (res) default value 0.1, different settings may necessary. h_xy numeric length 1 describing height range m stem base x y positions used calculate x y coordinates stem base. Default 0.3 m. res res numeric length 1 defining resolution voxel passed VoxR::vox(). Defaults 0.1 (10 cm voxel size). tree_name character vector length 1 name tree returned output object. Defaults NULL (take name tree argument).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"object class \"tree_pos\" containing following components: base_pos numeric vector length 3 x, y, z coordinates tree base position. crown_pos numeric vector length 3 x, y coordinates central point crown projected area z position stem base identified . height numeric length one containing tree height m. tree_name name object used \"tree\" argument, name specified user.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"Calculates stem base position, metroid crown projected area height tree data.frame  point cloud created read_pc(). stem base, z position taken z position first voxel layer containing least z_min points point cloud (standard value 100). done avoid outlying values affecting calculated stem base height usually consistent taking median z value lowermost group points, lower sensitivity outliers. x y position stem base calculated median voxelized x y coordinates voxels first h_xy m stem base (default: first 0.3 m - values low avoided stem shape may irregular close ground). central point crown projected area computed median x y position projected area tree. height based difference z value highest voxel belonging tree z value identified stem base. calculation done voxels ensure consistency downstream analyses reduce bias caused inhomogeneous point densities different sides stem. opinion, cases makes sense calculate competition indices based central point tree crown based stem base strongly inclined trees cylinder constructed around base may contain voxels crown central tree .","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"","code":"if (FALSE) { # \\dontrun{ # Read the tree point cloud tree <- read_tree(path = \"path/to/tree_point_cloud.txt\") # Get the position of this tree (x, y, z) pos <- tree_pos(tree) pos } # }"}]
