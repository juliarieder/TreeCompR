[{"path":"https://juliarieder.github.io/TreeCompR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 TreeCompR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"workflow-for-deriving-size-distance-dependent-competition-indizes-from-als-data","dir":"Articles","previous_headings":"","what":"Workflow for deriving size-distance-dependent competition indizes from ALS data","title":"ALS competition workflow","text":"Airborne Laser Scanning powerful tool forest management research, offering accurate large-scale data. quantify competition individual tree level, first ALS point cloud needs pre-processed. using data TreeCompR, need segment trees derive inventory table. package lidR great option load,inspect process ALS data segment individual trees. Check lidRbook nice detailed workflows examples.","code":"library(lidR) library(TreeCompR)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"read-the-point-cloud","dir":"Articles","previous_headings":"","what":"Read the point cloud","title":"ALS competition workflow","text":"lidR package can read various data formats. Read raw ALS point cloud. show workflow example data lidR package. Maybe just load xyz save memory, case lot parameters stored data, using optional parameter select within readLAS(). always good check validate data using las_check() function.","code":"LASfile <- system.file(\"extdata\", \"Megaplot.laz\", package=\"lidR\") las <- readLAS(LASfile) #print a summary print(las) las <- readLAS(\"file.las\", select = \"xyz\")  # load XYZ only las_check(las)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"plot-your-data","dir":"Articles","previous_headings":"","what":"Plot your data","title":"ALS competition workflow","text":"Please note, various options individual tree segmentations (e.g. based point cloud canopy height model). aware, based data, might need test approaches results check visually, results realistic. segmentation based CHM, first CHM needs generated:","code":"plot(las) # create CHM raster from point cloud with 0.5 m resolution (adjust values if needed) chm_p2r_05 <- rasterize_canopy(las, 0.5, p2r(subcircle = 0.2), pkg = \"terra\")  # Post-processing median filter kernel <- matrix(1,3,3) chm_p2r_05_smoothed <- terra::focal(chm_p2r_05, w = kernel, fun = median, na.rm = TRUE)  #locate tree tops ttops_chm_p2r_05_smoothed <- locate_trees(chm_p2r_05_smoothed, lmf(5)) col <- height.colors(50) plot(chm_p2r_05_smoothed, main = \"CHM P2R 0.5 smoothed\", col = col); plot(sf::st_geometry(ttops_chm_p2r_05_smoothed), add = T, pch =3)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"segment-the-trees","dir":"Articles","previous_headings":"","what":"Segment the trees","title":"ALS competition workflow","text":"","code":"algo <- dalponte2016(chm_p2r_05_smoothed, ttops_chm_p2r_05_smoothed) las <- segment_trees(las, algo) # segment point cloud plot(las, bg = \"white\", size = 4, color = \"treeID\") # visualize trees"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"get-crown-metrics","dir":"Articles","previous_headings":"","what":"Get crown metrics","title":"ALS competition workflow","text":"","code":"crowns <- crown_metrics(las, func = .stdtreemetrics, geom = \"convex\") plot(crowns[\"convhull_area\"], main = \"Crown area (convex hull)\") trees <- crown_metrics(las, func = .stdtreemetrics, geom = \"point\") plot(trees[\"Z\"], main = \"Tree heights\", pch = 16)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"integration-into-treecompr","dir":"Articles","previous_headings":"","what":"Integration into TreeCompR","title":"ALS competition workflow","text":"Extract inventory table crown data: validate inventory table read_inv() define target trees (automatically) define_targets() trees edge plot dataset (1 search radius away plot edge) automatically excluded calculating CIs.  Now can calculate tree competition (size-distance-dependent) trees. Afterwards can print results, save dataframe plot results according needs.","code":"library(sf) library(dplyr) inventory <- trees %>%   mutate(x = st_coordinates(.)[,1], y = st_coordinates(.)[,2]) %>%   st_set_geometry(NULL) inv_trees <- read_inv(inventory, height = Z, height_unit = \"m\") targets_buff <- define_target(inv_trees, target_source = \"buff_edge\", radius = 10) plot_target(targets_buff) CI <- compete_inv(inv_source = inv_trees, target_source = \"buff_edge\",                    radius = 10, method = \"all\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"plot-the-results","dir":"Articles","previous_headings":"","what":"plot the results","title":"ALS competition workflow","text":"","code":"library(ggplot2) ggplot(CI, aes(x = x, y = y, color = CI_Braathe)) +   geom_point(size = 2, alpha = 0.7) + # Adjust point size and transparency   scale_color_gradient(low = \"yellow\", high = \"darkred\",                         name = \"CI Braathe\") + # Customizing color scale   theme_classic() + # Change the theme   labs(title = \"Competition based on tree heights and distance\",         x = \"X\", y = \"Y\") + # Add title and axis labels   theme(     plot.title = element_text(hjust = 0.5), # Center the plot title     legend.position = \"right\" # Position of the legend   )"},{"path":"https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html","id":"other-options-to-pre-process-the-als-point-clouds","dir":"Articles","previous_headings":"","what":"Other options to pre-process the ALS point clouds","title":"ALS competition workflow","text":"packages available, e.g. itcSegment package. Within function itcLiDARallo(), trees segmented based typical allometric relations can defined beforehand. also used approach settings pre-process MLS data manuscript “TreeCompR: Tree competition indices inventory data 3D point clouds”. used publicly available laser scanning datasets Bavarian Agency Digitisation, High-Speed Internet Surveying.","code":"library(itcSegment)   # create a lookup table with common height-crown diameter-relations  # (example from itcSegment, also used in our case study) lut <- data.frame(   H = c(2, 10, 15, 20, 25, 30),   CD = c(0.5, 1, 2, 3, 4, 5))  #create a digital terrain model dtm <- grid_terrain(las = las, res = 0.5, algorithm = knnidw(k=10L, p=2)) plot(dtm) #normalize the height of the las data by terrain nlas <- las - dtm  # segment the trees (adjust epsg according to your coordinate reference system) se<-itcLiDARallo(nlas$X,nlas$Y,nlas$Z,epsg=32632,lut=lut) summary(se) plot(se,axes=T)  #validate the output in TreeCompR inv_trees <- read_inv(se, height = Height_m, height_unit = \"m\") #quantify tree competition (adjust radius) compete_inv(inv_source = inv_trees, target_source = \"buff_edge\",              radius = 13.5, method = \"all\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html","id":"pre-processing-of-tls-or-mls-point-clouds","dir":"Articles","previous_headings":"","what":"Pre-processing of TLS or MLS point clouds","title":"TLS competition workflow","text":"extracting information tree level close-range laser scanning (TLS MLS), can use e.g. TreeLS package. show workflow implement output TreeLS within TreeCompR. First load las data, normalize height, sample point cloud, estimate tree occurrence regions, classify stem points estimate diameter height individual tree.","code":"library(TreeCompR) library(TreeLS) file <- \"path/to/file\"     tls <- readTLS(file)     tls_norm <- tlsNormalize(tls, keep_ground = F)     thin <- tlsSample(tls_norm, smp.voxelize(0.01))     map <- treeMap(thin, map.hough(min_density = 0.1), 0)     tls_t <- treePoints(tls_norm, map, trp.crop())     tls_stem <- stemPoints(tls_t, stm.hough())     inv <- tlsInventory(tls_stem, d_method=shapeFit(shape='circle',                                                      algorithm = 'ransac'))     inv$dbh <- (inv$Radius *2)     inv"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html","id":"use-extracted-tree-information-within-treecompr","dir":"Articles","previous_headings":"","what":"Use extracted tree information within TreeCompR","title":"TLS competition workflow","text":"ensure inventory data assigned correctly, check data make sure specify units dbh height, differ default metres cases. Use read_inv() validate inventory data within TreeCompR. visually check, trees CIs quantified, depending chosen search radius, can use define_target() plot_target(). recommend use target_source = “buff_edge”, automatically calculate CI trees plot include trees, one search radius away forest edge. specifically important TLS/MLS data, since data usually cover whole forest forest plot.","code":"inventory <- read_inv(inv_source = inv, dbh_unit = \"m\", height_unit = \"m\") targets <- define_target(inv = inventory, target_source = \"buff_edge\", radius = 10) plot_target(targets) compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                method = \"all_methods\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html","id":"user-cases","dir":"Articles","previous_headings":"","what":"User cases","title":"TLS competition workflow","text":"","code":"## If you focus on a specific CI, e.g. the widely used Hegyi-Index,  ## you can choose it within methods = \"CI_Hegyi\". compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                method = \"CI_Hegyi\")  ## If you have a tree height column that is not automatically recognized within  ## our validation of input data, you can set it manually: # in read_inv(): inventory <- read_inv(inv_source = inventory, height = \"h_column_name\")  # in compete_inv(): compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                height = \"h_column_name\", method = \"CI_Hegyi\")  ## If your dbh is specified in cm, just change the dbh_unit to \"cm\" compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                dbh_unit = \"cm\", method = \"CI_Hegyi\")  ## If you want to keep a column with certain user defined IDs for the trees,  ## and it is not recognized, specify it with id = \"name_column\" inventory <- read_inv(inv_source = inventory, id = \"ID_user\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"TreeCompR","text":"can install development version TreeCompR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"juliarieder/TreeCompR\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"TreeCompR","text":"TreeCompR can read point clouds inventory tables quantifies tree competition different ways: read_pc() reads 3D point clouds dataframe format las/laz (already loaded file path) read_inv() reads validates inventory tables dataframes reads table directly file path define_target() can used define trees within plot competition quantified compete_inv() plot_target() check validate tree position(s) surrounding trees defining define_target() compete_pc() quantifies tree competition point clouds (methods: cone cylinder) compete_inv()quantifies size- distance-dependent competition using inventory data","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"methodology-of-point-cloud-based-approach","dir":"Articles","previous_headings":"","what":"Methodology of point cloud-based approach","title":"TreeCompR","text":"LiDAR point clouds can used directly quantify competition exerted neighboring trees target tree. purpose, target tree competition determined segmented beforehand. Since crucial whether part point cloud classified “competing” part target tree , manual segmentation (e.g. CloudCompare) accurate.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"TreeCompR","text":"quantify competition compete_pc() one target tree using cone method (cone spanned 60 % target tree’s height) cylinder method 5 m radius:","code":"library(TreeCompR) ## insert path to point cloud of the forest plot and to the target tree  compete_pc(forest_source = \"../tests/testthat/testdata/neighborhood.txt\",             tree_source = \"../tests/testthat/testdata/tree.txt\",             comp_method = \"cone\",            h_cone = 0.6) ## or the cylinder method with radius 5 m compete_pc(forest_source = \"../tests/testthat/testdata/neighborhood.txt\",             tree_source = \"../tests/testthat/testdata/tree.txt\",             comp_method = \"cylinder\", cyl_r = 5)"},{"path":"https://juliarieder.github.io/TreeCompR/articles/TreeCompR.html","id":"size--and-distance-dependent-tree-competition","dir":"Articles","previous_headings":"Example","what":"Size- and distance-dependent tree competition","title":"TreeCompR","text":"Distance-dependent competition indices can quantified using compete_inv()","code":"## check or define target trees: read inventory file and define targets plot <- read_inv(\"../tests/testthat/testdata/inventory.csv\", verbose = FALSE) targets <- define_target(plot,target_source = \"buff_edge\", radius = 10) ## plot the positions of the target trees and trees at the border plot_target(targets) ## insert path to inventory table or insert dataframe object compete_inv(inv_source = plot,             target_source = targets,             radius = 10, method = \"all\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Quantify competition from inventory data","text":"Within TreeCompR possible easily derive size-distance-dependent competition indices based inventory data. data can collected field, derived modelled 3D point clouds. Depending input data, necessary pre-processing steps. Check workflows: airborne laser scanning data competition indices vignette(“ALS_inventory”) ground-based laser scanning data (MLS/TLS) competition indices vignette(“TLS_inventory”)","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"use-inventory-data-within-treecompr","dir":"Articles","previous_headings":"","what":"Use inventory data within TreeCompR","title":"Quantify competition from inventory data","text":"inventory data must contain x y coordinates individual trees least one variable (e.g. height dbh). ensure inventory data assigned correctly, check data make sure specify units dbh height, differ default metres cases. Use read_inv() validate inventory data within TreeCompR. visually check, trees CIs quantified, depending chosen search radius, can use define_target() plot_target(). recommend use target_source = “buff_edge”, automatically calculate CI trees plot include trees, one search radius away forest edge. specifically important TLS/MLS data, since data usually cover whole forest forest plot.","code":"library(TreeCompR) inventory <- read_inv(inv_source = inv, dbh_unit = \"m\", height_unit = \"m\") targets <- define_target(inv = inventory, target_source = \"buff_edge\", radius = 10) plot_target(targets) compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                method = \"all_methods\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-inventory.html","id":"user-cases","dir":"Articles","previous_headings":"","what":"User cases","title":"Quantify competition from inventory data","text":"","code":"## read inventory from file directory inventory <- read_inv(inv_source = \"path/to/file\")  ## If you focus on a specific CI, e.g. the widely used Hegyi-Index,  ## you can choose it within methods = \"CI_Hegyi\". compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                method = \"CI_Hegyi\")  ## If you have a tree height column that is not automatically recognized within  ## our validation of input data, you can set it manually: # in read_inv(): inventory <- read_inv(inv_source = inventory, height = \"h_column_name\")  # in compete_inv(): compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                height = \"h_column_name\", method = \"CI_Hegyi\")  ## If your dbh is specified in cm, just change the dbh_unit to \"cm\" compete_inv(inventory, target_source = \"buff_edge\", radius = 10,                dbh_unit = \"cm\", method = \"CI_Hegyi\")  ## If you want to keep a column with certain user defined IDs for the trees,  ## and it is not recognized, specify it with id = \"name_column\" inventory <- read_inv(inv_source = inventory, id = \"ID_user\")"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-pointcloud.html","id":"pre-process-the-point-clouds","dir":"Articles","previous_headings":"","what":"Pre-process the point clouds","title":"Quantify competition from point clouds","text":"using cone cylinder point cloud approaches, trees competition quantified must extracted plot. accurate way CloudCompare. Load point cloud whole plot use Segment function extract target tree. Make sure miss part include neighbouring trees branches, crucial determine parts point cloud neighbours points belong target tree. Pay particular attention ground don’t include ground points target tree’s point cloud, otherwise tree’s position may shifted later function takes lowest points account.  extracting target tree, export point cloud selecting file DB Tree click File - Save. whole plot, first clip point cloud area interest. best way select top view use [Cross Section] function (https://www.cloudcompare.org/doc/wiki/index.php/Cross_Section) clip point cloud. Make sure target tree edge plot. used 30x30m plots. exporting/saving point clouds, can select .las/.laz, .txt, .csv, … clicking save, asked select output resolution. choose custom resolution coordinate accuracy, make sure choose target tree neighbourhood cloud!","code":""},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-pointcloud.html","id":"quantify-competition-with-treecompr","dir":"Articles","previous_headings":"","what":"Quantify Competition with TreeCompR","title":"Quantify competition from point clouds","text":"two point clouds, can use TreeCompR. Read validate point clouds (target tree neighbourhood). Select method competition method (comp_method) “cylinder” “cone” “”. Also position center cone cylinder can “set” either crown position (“crown_pos”) base position (“base_pos”). Usually tree position calculated using lowest points tree take mean median, tree growing straight, want identify (crown-)competition, think useful go medoid crown (crown center). want use base position, additional parameters can adjust, h_xy (height m stem base position xy calculated ) z_min (minimum number points lowermost 0.1 m tree calculate base position tree). Read methods settings sensitivity Seidel et al., 2015, Metz et al., 2013 original KKL index Pretzsch et al., 2002. result data frame can save use statistical analysis. contains name ID (filename) tree, height tree, center_position used, CI value(s) main parameter settings. want use neighbourhood , one target tree within plot, need read point cloud file time. Read read_pc() use . can also load target tree outside compete_pc() function.","code":"library(TreeCompR)  CI <- compete_pc(forest_source = \"../tests/testthat/testdata/neighborhood.txt\",                  tree_source = \"../tests/testthat/testdata/tree.txt\",                  comp_method = \"both\", # calculate CI in cylinder and cone                 center_position = \"crown_pos\", #center for cone and cylinder                 cyl_r = 4, #radius in m                 h_cone = 0.6, #set height where the cone starts                  #to open in relation to tree height (0.6 = 60 % of tree height)                 print_progress = \"some\" #get some information during processing                 ) neighbours <- read_pc(\"../tests/testthat/testdata/neighborhood.txt\") tree <- read_pc(\"../tests/testthat/testdata/tree.txt\")  CI <- compete_pc(forest_source = neighbours,                  tree_source = tree,                  comp_method = \"both\", # calculate CI in cylinder and cone                 center_position = \"crown_pos\", #center for cone and cylinder                 cyl_r = 4, #radius in m                 h_cone = 0.6, #set height where the cone starts                  #to open in relation to tree height (0.6 = 60 % of tree height)                 print_progress = \"full\" #get full information during processing                 )"},{"path":"https://juliarieder.github.io/TreeCompR/articles/competition-pointcloud.html","id":"example-for-batch-processing","dir":"Articles","previous_headings":"","what":"Example for batch-processing","title":"Quantify competition from point clouds","text":"study consists many target trees surrounding plots, may useful create lookup table run function trees. example lookup table might look like:","code":"# Define the base paths neighborhood_path <- \"/path/to/neighborhood/\" trees_path <- \"/path/to/trees/\"  # List files in the neighborhood and tree folders neighborhood_files <- list.files(neighborhood_path, full.names = TRUE,                                   pattern = \"\\\\.las$\") tree_files <- list.files(trees_path, full.names = TRUE, pattern = \"\\\\.las$\")  # Create TreeIDs if needed # Assuming the same number of neighborhood and tree files,  #and each tree has a corresponding neighborhood file TreeIDs <- paste0(\"Tree_\", seq_along(neighborhood_files))  # Create the lookup table as a data frame lookup_table <- data.frame(   TreeID = TreeIDs,   forest_source = neighborhood_files,   tree_source = tree_files,   stringsAsFactors = FALSE ) # Print the lookup table print(lookup_table) #>   TreeID                            forest_source               tree_source #> 1 Tree_1 /path/to/neighborhood/neighborhood_1.las /path/to/trees/tree_1.las #> 2 Tree_2 /path/to/neighborhood/neighborhood_2.las /path/to/trees/tree_2.las #> 3 Tree_3 /path/to/neighborhood/neighborhood_3.las /path/to/trees/tree_3.las #> 4 Tree_4 /path/to/neighborhood/neighborhood_4.las /path/to/trees/tree_4.las #> 5 Tree_5 /path/to/neighborhood/neighborhood_5.las /path/to/trees/tree_5.las #calculate both methods at the same time library(dplyr) lookup <- lookup_table %>% dplyr::select(forest_source, tree_source) #define parameter settings within the lookup table lookup_cone50_cyl5 <- lookup %>% dplyr::mutate(comp_method = \"both\",                                                 center_position = \"crown_pos\",                                                 cyl_r = 5, h_cone = 0.5,                                                 z_min = 100, h_xy = 0.3,                                                 print_progress = \"some\") #use pmap (alternative to lapply) to loop over your table lookup_results_cone50_cyl5 <- lookup_cone50_cyl5 %>% purrr::pmap(compete_pc)  #re-structure results from list to dataframe results <- as.data.frame(do.call(rbind, lookup_results_cone50_cyl5))"},{"path":"https://juliarieder.github.io/TreeCompR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Julia S. Rieder. Author, maintainer. Roman M. Link. Author.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rieder J, Link R (2024). TreeCompR: Tree Competition Indices Inventory Data 3D Point Clouds. R package version 0.0.0.9000, https://juliarieder.github.io/TreeCompR/.","code":"@Manual{,   title = {TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds},   author = {Julia S. Rieder and Roman M. Link},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://juliarieder.github.io/TreeCompR/}, }"},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"treecompr","dir":"","previous_headings":"","what":"Tree Competition Indices For Inventory Data And 3D Point Clouds","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"R Package calculating distance-dependent point cloud-based individual tree competition indices R package designed quantitative analysis individual tree competition within forest ecosystems. accepts inputs LiDAR point clouds (dataframe xyz columns las/laz files) forest plots individual target trees, inventory tables (including tree ID, x, y, dbh /h). use various competition indices, enables assessment measurement competition trees, providing valuable insights forest ecology, inventories, forest management strategies. package facilitates systematic approach understanding interactions resource competition among trees enables informed decision making forest management.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"can install development version TreeCompR GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"juliarieder/TreeCompR\", dependencies = TRUE)  # or with vignettes on your computer devtools::install_github(\"juliarieder/TreeCompR\",              dependencies = TRUE, build_vignettes = TRUE)"},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"TreeCompR can read point clouds inventory tables quantifies tree competition different ways: read_pc() reads 3D point clouds dataframe format las/laz (already loaded file path) read_inv() reads validates inventory tables dataframes reads table directly file path define_target() can used define trees within plot competition quantified compete_inv() plot_target() check validate tree position(s) surrounding trees defining define_target() compete_pc() quantifies tree competition point clouds (methods: cone cylinder) compete_inv()quantifies size- distance-dependent competition using inventory data","code":""},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"methodology-of-point-cloud-based-approach","dir":"","previous_headings":"","what":"Methodology of point cloud-based approach","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"LiDAR point clouds can used directly quantify competition exerted neighboring trees target tree. purpose, target tree competition determined segmented beforehand. Since crucial whether part point cloud classified “competing” part target tree , manual segmentation (e.g. CloudCompare) accurate.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"quantify competition compete_pc() one target tree using cone method (cone spanned 60 % target tree’s height) cylinder method 5 m radius:","code":"library(TreeCompR) ## insert path to point cloud of the forest plot and to the target tree  compete_pc(forest_source = \"tests/testthat/testdata/neighborhood.txt\",             tree_source = \"tests/testthat/testdata/tree.txt\",             comp_method = \"cone\",            h_cone = 0.6) #> ----- Processing competition indices for: tree ----- #> Cone-based CI = 16046 #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cone h_cone #> 1   tree          22.8    crown center   16046    0.6 ## or the cylinder method with radius 5 m compete_pc(forest_source = \"tests/testthat/testdata/neighborhood.txt\",             tree_source = \"tests/testthat/testdata/tree.txt\",             comp_method = \"cylinder\", cyl_r = 5) #> ----- Processing competition indices for: tree ----- #> Cylinder-based CI = 102169 #>  ------------------------------------------------------------------ #>  Point cloud based competition indices for 'tree'  #>  ------------------------------------------------------------------ #>   target height_target center_position CI_cyl cyl_r #> 1   tree          22.8    crown center 102169     5"},{"path":"https://juliarieder.github.io/TreeCompR/index.html","id":"size--and-distance-dependent-tree-competition","dir":"","previous_headings":"","what":"Size- and distance-dependent tree competition","title":"Tree Competition Indices For Inventory Data And 3D Point Clouds","text":"Distance-dependent competition indices can quantified using compete_inv()","code":"## check or define target trees: read inventory file and define targets plot <- read_inv(\"tests/testthat/testdata/inventory.csv\", verbose = FALSE) targets <- define_target(plot,target_source = \"buff_edge\", radius = 10) ## plot the positions of the target trees and trees at the border plot_target(targets) ## insert path to inventory table or insert dataframe object compete_inv(inv_source = \"tests/testthat/testdata/inventory.csv\",             target_source = \"buff_edge\",             radius = 10, method = \"all\") #> ---------------------------------------------------------------------  #> 'compete_inv' class inventory with distance-based competition indices  #> Collection of data for 1 target and 47 edge trees.  #> Source of target trees: buffer around edge    Search radius: 10  #> --------------------------------------------------------------------- #>    id     x      y   dbh CI_Hegyi CI_RK1 CI_RK2 #> 44 48 0.102 -0.494 0.244     4.39   1.07   1.58"},{"path":"https://juliarieder.github.io/TreeCompR/reference/TreeCompR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds — TreeCompR-package","title":"TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds — TreeCompR-package","text":"Quantify individual tree competition using inventory data point clouds.","code":""},{"path":[]},{"path":"https://juliarieder.github.io/TreeCompR/reference/TreeCompR-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"TreeCompR: Tree Competition Indices For Inventory Data And 3D Point Clouds — TreeCompR-package","text":"Maintainer: Julia S. Rieder julia.rieder@uni-wuerzburg.de (ORCID) Authors: Roman M. Link roman.link@plant-ecology.de (ORCID)","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify size- and distance-dependent competition using inventory data — compete_inv","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"'compete_inv()' returns specific distance-height-dependent distance- dbh-dependent competition index (group indices) trees within forest plot specified target trees.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"","code":"compete_inv(   inv_source,   target_source,   radius,   method = c(\"all_methods\", \"CI_Hegyi\", \"CI_Braathe\", \"CI_RK1\", \"CI_RK2\", \"CI_RK3\",     \"CI_RK4\"),   x = NULL,   y = NULL,   dbh = NULL,   height = NULL,   id = NULL,   dbh_unit = c(\"cm\", \"m\", \"mm\"),   height_unit = c(\"m\", \"cm\", \"mm\"),   verbose = TRUE,   tol = 1,   ... )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"inv_source either object class target_inv, object can imported read_inv() (case, x, y, id, dbh, /height can specified function – see corresponding documentation details). provided target_inv object, function ignores target_source overrides arguments passed read_inv() define_target(). target_source one following: path object can imported read_inv() (case, column specifications inv_source - possible, load outside compete_inv()). vector class \"character\" containing tree IDs identifying target trees  format id column inv, vector class logical specifying row inv whether corresponding tree target tree, another object class forest_inv containing coordinates target trees. case, coordinates matched coordinates inv IDs may differ (useful e.g. target trees defined based GPS coordinates matched airborne laser scanning dataset). character vector length 1 defining method target trees determined. Allowed \"buff_edge\" excluding trees least one search radius forest edge, \"exclude_edge\" excluding edge trees \"all_trees\" including trees dataset (hardly ever good idea unless trees entire forest dataset). standard \"buff_edge\". See define_target() details. radius numeric length 1. Search radius (m) around target tree. neighboring trees within radius classified competitors. method character string assigning method quantifying competition. dbh-distance-dependent methods \"CI_Hegyi\", \"CI_RK1\", \"CI_RK2\". Height-distance-dependent methods \"CI_Braathe\", \"CI_RK3\", \"CI_RK4\". \"all_methods\" can specified compute indices can calculated available data. x character length 1 name variable inv_source containing x coordinates tree m. NULL (default), function tries identify x coordinate data. y character length 1 name variable inv_source containing y coordinates tree meters. NULL (default), function tries identify y coordinate data. dbh character length 1 name variable inv_source containing diameter breast height tree (default cm, can defined via dbh_unit). NULL (default), function tries identify dbh data. height character length 1 name variable inv_source containing height tree (default m,   can defined via heigh_unit). NULL (default), function tries identify height data. id character length 1 name variable inv_source containing unique tree ID. NULL (default), function tries identify ID data. possible, trees assigned unique number. IDs coerced character. dbh_unit character length 1. Unit diameter measurements (one \"cm\", \"m\" \"mm\". defaults \"cm\"). height_unit character length 1. Unit diameter measurements (one \"m\", \"cm\" \"mm\". defaults \"m\"). verbose logical length 1. information progress printed? Defaults TRUE. tol numeric length 1. Tolerance match tree coordinates. coordinates measured field GPS, inv_source contains x y coordinates larger number trees obtained segmentation, tolerance matching forest inventory target tree positions. forest tree within tolerance target tree, competition indices calculated tree function return warning. tol defaults 1 m, chosen depending measurement accuracy GPS coordinates. ... additional arguments passed data.table::fread().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"compete_inv object: modified data.frame forest invetory data, target tree specifications competition indices depending chosen method.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"Using inventory table easily quantify distance-dependent tree competition list trees within plot trees. input data can either taken directly field measurements derived beforehand LiDAR point clouds. function calculates 6 different Competition indices, based tree heights dbh distance competitors.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"available competition indices computed according following equations, \\(d_i\\) \\(h_i\\) dbh height neighbor tree \\(\\), \\(d\\) \\(h\\) dbh height focal tree, \\(dist_i\\) distance neighbor tree \\(\\).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"diameter-based-competition-indices","dir":"Reference","previous_headings":"","what":"Diameter-based competition indices","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"CI_Hegyi introduced Hegyi (1974):  \\(CI_{Hegyi} = \\sum_{=1}^{n} d_{} / (d \\cdot dist_{})\\) CI_RK1 according CI1 Rouvinen & Kuuluvainen (1997): \\(CI_{RK1} = \\sum_{=1}^{n} \\mathrm{arctan}(d_{} / dist_{})\\) CI_RK2 according CI3 Rouvinen & Kuuluvainen (1997):  \\(CI_{RK2} =\\sum_{=1}^{n} (d_{} / d) \\cdot \\mathrm{arctan}(d_{}    / dist_{})\\)","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"height-based-competition-indices","dir":"Reference","previous_headings":"","what":"Height-based competition indices","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"CI_Braathe according Braathe (1980):  \\(CI_{Braathe} = \\sum_{=1}^{n} h_{} / (h \\cdot dist_{})\\) CI_RK3 according CI5 Rouvinen & Kuuluvainen (1997):  \\(CI_{RK3} = \\sum_{=1}^{n} \\mathrm{arctan}(h_{} / dist_{})\\) trees \\(h_{} > h\\) CI_RK4 based CI3 Rouvinen & Kuuluvainen (1997) Contreras et al. (2011):  \\(CI_{RK4} = \\sum_{=1}^{n} (h_{} / h) \\cdot    \\mathrm{arctan}(h_{} / dist_{})\\)","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"tree-segmentation","dir":"Reference","previous_headings":"","what":"Tree Segmentation","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"Various approaches can used segment (airborne) laser scanning point clouds single trees obtain inventory data based . Existing R packages example: TreeLS package automated segmentation terrestrial/mobile laser scans lidR package different options segment point cloud Canopy Height Model (CHM) itcLiDARallo within package itcSegment careful low resolution/low density point clouds, oversegmentation trees usually issue!","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"literature","dir":"Reference","previous_headings":"","what":"Literature","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"Hegyi, F., 1974. simulation model managing jackpine stands. : Fries, J. (Ed.), Proceedings IUFRO meeting S4.01.04 Growth models tree stand simulation, Royal College Forestry, Stockholm. Braathe, P., 1980. Height increment young single trees relation height distance neighboring trees. Mitt. Forstl. VersAnst. 130, 43–48. Rouvinen, S., Kuuluvainen, T., 1997. Structure asymmetry tree crowns relation local competition natural mature Scot pine forest. Can. J. . Res. 27, 890–902. Contreras, M.., Affleck, D. & Chung, W., 2011. Evaluating tree competition indices predictors basal area increment western Montana forests. Forest Ecology Management, 262(11): 1939-1949.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_inv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify size- and distance-dependent competition using inventory data — compete_inv","text":"","code":"if (FALSE) { # \\dontrun{ # Quantify the Hegyi index for specified target trees with search radius 10m CI <- compete_inv(\"path/to/invtable.csv\",   \"path/to/target_trees.csv\", radius = 10, method = \"CI_Hegyi\") # Quantify the Braathe index for specified target trees with search radius #10m and adjust CI <- compete_inv(\"path/to/invtable.csv\",   \"path/to/target_trees.csv\", radius = 10, method = \"CI_Braathe\") # Specify the units of dbh or height of your input data CI <- compete_inv(\"path/to/invtable.csv\",   \"path/to/target_trees.csv\", radius = 10, method = \"CI_Hegyi\",   dbh_unit = \"m\", height_unit = \"m\") # Quantify all available indices for all trees within the plot that are one #search radius away from plot edge CI <- compete_inv(\"path/to/invtable.csv\", target_source = \"buff_edge\",         radius = 12, method = \"all_methods\") } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify tree competition from point clouds — compete_pc","title":"Quantify tree competition from point clouds — compete_pc","text":"Counts voxels neighboring trees intersect search cone search cylinder around target tree according Seidel et al. (2015) Metz et al. (2013).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify tree competition from point clouds — compete_pc","text":"","code":"compete_pc(   forest_source,   tree_source,   comp_method = c(\"cone\", \"cylinder\", \"both\"),   center_position = c(\"crown_pos\", \"base_pos\"),   tree_name = NULL,   cyl_r = 5,   h_cone = 0.6,   z_min = 100,   h_xy = 0.3,   acc_digits = 2,   res = 0.1,   print_progress = c(\"some\", \"full\", \"none\"),   override_pos_check = FALSE,   ... )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify tree competition from point clouds — compete_pc","text":"forest_source path file neighborhood point cloud data.frame LAS object (see lidR::LAS) point cloud data passed read_pc(), object class forest_pc created read_pc(). neighborhood can, include target tree , height normalized, can include ground points. Coordinates Cartesian coordinate system m. paths source files, supported formats .las, .laz, .ply well formats accepted data.table::fread() (.csv, .txt, others). tree_source path file point cloud segmented target, tree data.frame LAS object (see lidR::LAS) point cloud data passed read_pc(), object class forest_pc created read_pc(). Coordinates coordinate system forest_source. paths source files, supported formats .las, .laz, .ply formats accepted data.table::fread(). comp_method character string length 1 competition method. Allowed values \"cone\" cone method, \"cylinder\" cylinder method \"\" methods. Default cone method. See details computation. center_position character string length 1 position used center search cone/cylinder. Allowed values \"crown_pos\" central point crown projected area \"base_pos\" stem base position computed tree_pos(). Default value \"crown_pos\". tree_name (optional) ID tree. argument put, defaults name argument provided tree_source. cyl_r (optional) needed using comp_method \"cylinder\"; numeric value cylinder radius m. Default 5 m. h_cone (optional) using comp_method \"cone\"; numeric value describing fraction height tree tip search cone located. example, values 0.5 0.6 specify cone opens 50 60 % target tree's height, respectively. Default 0.6 proposed Seidel et al. (2015). z_min integer length 1 describing minimum number points needed lowermost 1 voxel depth Z layer consider part target tree. Default 100. changing voxel resolution (res) default value 0.1, different settings may necessary.  Used calculate stem base position target tree. details see tree_pos(). h_xy numeric length 1 describing height range m stem base x y positions used calculate x y coordinates stem base target tree. Default 0.3 m. Used calculate stem base position target tree. details see tree_pos(). acc_digits integer length 1 defining number digits accuracy point cloud measurements. Data rounded internally value speed calculations avoid problems joining tree neighborhood data resulting numeric accuracy. Defaults 2 (round 2 digits decimal point). res numeric length 1 defining resolution voxel passed VoxR::vox(). Defaults 0.1 (10 cm voxel size). change good reasons standard used Seidel et al. (2015) papers results strongly scale dependent! print_progress character length 1. Allowed values \"full\" (print progress full output), \"\" (print main details) \"none\" (print progress). Defaults \"\". override_pos_check logical: function test target tree actually situated within neighborhood? Defaults FALSE. change good reasons , e.g., computing competition tree situated edge forest stand. ... additional arguments passed data.table::fread().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify tree competition from point clouds — compete_pc","text":"data frame tree ID counted voxels neighborhood point cloud reach cone/cylinder spanned /around target tree.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantify tree competition from point clouds — compete_pc","text":"compete_pc() computes competition indices based voxel counts neighbor trees intersect search cone search cylinder around target tree. cases, function read_pc() called internally able automatically identify columns coordinates point clouds provided non-standard file types. case, possible provide arguments pass function, load datasets separately custom settings read_pc() loading external functions pass compete_pc() kind object inheriting data.frame (base R data.frames, tibbles, data.tables etc).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"cone-method","dir":"Reference","previous_headings":"","what":"Cone Method","title":"Quantify tree competition from point clouds — compete_pc","text":"Based search cone opening angle 60 degrees, default opening basal point situated 60 % height target tree. competition index defined number voxels neighboring trees  (default, 0.1 m res.) situated within cone spanned around target tree (cf. Metz et al 2013; Seidel et al., 2015). standard value h_cone = 0.6 can adjusted, instance neighbor trees intersect cone target tree. However, careful adjusting parameter, competition indices computed different h_cone easily compared among .","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"cylinder-method","dir":"Reference","previous_headings":"","what":"Cylinder Method","title":"Quantify tree competition from point clouds — compete_pc","text":"Based  search cylinder pre-defined radius cyl_r around target tree (5 m default). competition index defined number voxels neighboring trees  (default, 0.1 m res.) situated within cylinder around target tree (cf. Seidel et al., 2015). index sensitive choice cylinder radius, careful comparing competition indices computed different values cyl_r. indices highly sensitive voxel resolution, recommended change res default value 0.1 (.e., 10 cm voxel size) unless good reasons . calculating competition indices single trees accompanying point cloud immediate neighborhood, using file paths datasets tree_source / neighbor_source computationally efficient. However, calculating indices several trees belonging neighborhood, may faster load neighborhood outside compete_pc() single time using read_pc() passing compete_pc() forest_pc object reduces computational overhead due loading point cloud memory. cases, may also make sense load process forest point cloud LAS object (see lidR::LAS) process outside TreeCompR analysis. source files large, may still lead memory problems especially machines low RAM capacity. cases, may make sense split data set smaller chunks outside R reduce memory load.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"note-support-of-las-laz-and-ply-formats","dir":"Reference","previous_headings":"","what":"Note: support of .las, .laz and .ply formats","title":"Quantify tree competition from point clouds — compete_pc","text":"'lidR' package installed able read .las/.laz files, internally processed lidR::readTLSLAS(). Analogously, point clouds .ply format, 'Rvcg' package required loaded Rvcg::vcgPlyRead().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"literature","dir":"Reference","previous_headings":"","what":"Literature","title":"Quantify tree competition from point clouds — compete_pc","text":"Metz, J., Seidel, D., Schall, P., Scheffer, D., Schulze, E.-D. & Ammer, C. (2013). Crown modeling terrestrial laser scanning approach assess effect aboveground intra- interspecific competition tree growth. Forest Ecology Management,310:275-288. https://doi.org/10.1016/j.foreco.2013.08.014 Pretzsch, H., Biber, P. & Dursky, J. (2002). single tree-based stand simulator SILVA: construction, application evaluation. . Ecol. Manage. 162, 3-21. https://doi.org/10.1016/S0378-1127(02)00047-6 Seidel, D., Hoffmann, N., Ehbrecht, M., Juchheim, J. & Ammer, C. (2015). neighborhood affects tree diameter increment - New insights terrestrial laser scanning methodical considerations. Forest Ecology Management, 336: 119-128. http://dx.doi.org/10.1016/j.foreco.2014.10.020","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/compete_pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify tree competition from point clouds — compete_pc","text":"","code":"if (FALSE) { # \\dontrun{ # Due to the large required datasets it is not possible to provide running # examples, but we hope that these example uses are helpful  # Quantifying crown competition for a single tree using the cone method CI_cone <- compete_pc(\"path/to/forest_pc.las\", \"path/to/tree_pc.las\",                           \"cone\", h_cone = 0.5)  # Competition for a single tree using the cylinder method with 4 m radius CI_cyl <- compete_pc(\"path/to/forest_pc.ply\", \"path/to/tree_pc.ply\", \"cylinder\", cyl_r = 4)  # Quantifying competition for a single tree using both methods CI_cyl <- compete_pc(\"path/to/forest_pc.txt\", \"path/to/tree_pc.txt\", \"cylinder\", cyl_r = 4, h_cone = 0.6)  # Loading a large neighborhood outside compete_pc() to reuse the data for # several target trees  # load neighborhood neigh <- read_pc(\"path/to/forest_pc.las\")  # get paths to trees tree_paths <- list.files(\"folder_with_trees/\")  # map over paths to get competition indices for all trees library(tidyverse) # for purrr() and bind_rows() CI_data <- map(   tree_paths,   ~compete_pc(       forest_source = neigh,       tree_source = file.path(\"folder_with_trees\", .x),       tree_name = .x,       method = \"cone\"       )     ) %>%     bind_rows() } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":null,"dir":"Reference","previous_headings":"","what":"Define target trees in forest inventory data — define_target","title":"Define target trees in forest inventory data — define_target","text":"define_target() takes forest_inv dataset returns updated forest inventory highlighted target trees analysis compete_inv. Target trees can manually specified tree ID, imported different dataset identified automatically excluding edge trees coordinates.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define target trees in forest inventory data — define_target","text":"","code":"define_target(inv, target_source, radius = 10, tol = 1, verbose = TRUE)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define target trees in forest inventory data — define_target","text":"inv object class forest_inv created read_inv(). target_source one following: vector class \"character\" containing tree IDs identifying target trees  format id column inv. vector class logical specifying row inv whether corresponding tree target tree. another object class forest_inv containing coordinates target trees. case, coordinates matched coordinates inv IDs may differ (useful e.g. target trees defined based GPS coordinates matched airborne laser scanning dataset). case, extent inv cropped extent forest_inv \\(\\pm\\) radius + tol reduce computational load. character vector length 1 defining method target trees determined. Allowed \"buff_edge\" excluding trees least one search radius forest edge, \"exclude_edge\" excluding edge trees \"all_trees\" including trees dataset (hardly ever good idea unless trees entire forest dataset). standard \"buff_edge\". See details. radius numeric length 1, Search radius (m) around target tree wherein neighboring trees classified competitors. used target_source \"buff_edge\", \"exclude_edge\" type forest_inv. Defaults 10. tol numeric. Tolerance match tree coordinates forest inventory target datasets specified second set coordinates. field measurements (e.g. based GPS) used identify target trees full inventory different data source (e.g. ALS data), higher tolerance value may required identify trees depending measurement accuracy. Values 0 mean exact matching. verbose logical length 1. information progress printed? Defaults TRUE.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define target trees in forest inventory data — define_target","text":"object c(\"target_inv\", \"forest_inv\", \"data.frame\") x y coordinates tree, unique tree identifier (id), least one tree diameter breast height (dbh, cm) tree height (height, m) new logical column target specifying whether tree considered target tree.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define target trees in forest inventory data — define_target","text":"input data can either taken directly field measurements derived beforehand LiDAR point clouds. Various approaches can used segment airborne laser scanning point clouds single trees obtain inventory data based . Existing R packages example: lidR package different options segment point cloud Canopy Height Model (CHM) itcLiDARallo within package itcSegment careful low resolution/low density point clouds, oversegmentation trees usually issue!","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/define_target.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define target trees in forest inventory data — define_target","text":"","code":"if (FALSE) { # \\dontrun{ # read inventory inv <- read_inv(\"path/to/invtable.csv\") #or just validate your already loaded inventory data #e.g.extracted from lidR package inv <- read_inv(inventory, height = Z, height_unit = \"m\") # or from itcSegment (itcLiDARallo) inv <- read_inv(inventory, height = Height_m, height_unit = \"m\") # target trees defined by a buffer around the plot edges target <- define_target(inv, target_source = \"buff_edge\", radius = 10) #or if your trees are definitely at a forest edge #(and not just at the edge of your dataset) you can include all trees target <- define_target(inv, target_source = \"all_trees\", radius = 10) } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot selection of target trees — plot_target","title":"Plot selection of target trees — plot_target","text":"plot_target() can used  target_inv dataset output compete_inv function inspect spatial positions target trees.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot selection of target trees — plot_target","text":"","code":"plot_target(inv, radius = NULL)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot selection of target trees — plot_target","text":"inv object class compete_inv target_inv. radius numeric length 1, Search radius (m) around target tree wherein neighboring trees classified competitors. needed target_inv objects methods radius dependent (.e., cases target_source defined character logical vector cases target_source = \"all_trees\").","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot selection of target trees — plot_target","text":"plot spatial arrangement target trees.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot selection of target trees — plot_target","text":"function creates plot trees forest inventory dataset target trees surrounding search radii highlighted. created target_source = \"buff_edge\" target_source = \"exclude_edge\", estimated plot margin (, case \"buff_edge\", also buffer margin) added polygon. function meant visual inspection tool checking validity choice target trees.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/plot_target.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot selection of target trees — plot_target","text":"","code":"if (FALSE) { # \\dontrun{   # plot neighborhood for existing inventory   comp <- compete_inv(inv, \"buff_edge\", radius = 10)   plot_target(comp) } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":null,"dir":"Reference","previous_headings":"","what":"Read forest inventory data — read_inv","title":"Read forest inventory data — read_inv","text":"Read inventory table sourced file path object inherits class data.frame.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read forest inventory data — read_inv","text":"","code":"read_inv(   inv_source,   x = NULL,   y = NULL,   dbh = NULL,   height = NULL,   id = NULL,   dbh_unit = c(\"cm\", \"m\", \"mm\"),   height_unit = c(\"m\", \"cm\", \"mm\"),   verbose = TRUE,   names_as_is = FALSE,   ... )"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read forest inventory data — read_inv","text":"inv_source object inherits class data.frame, character path file file format readable data.table::fread(). provided forest inventory data data.frame, structure column names validated homogenized; else, function tries read dataset specified path. x character length 1 name variable inv_source containing x coordinates tree m. NULL (default), function tries identify x coordinate data. y character length 1 name variable inv_source containing y coordinates tree meters. NULL (default), function tries identify y coordinate data. dbh character length 1 name variable inv_source containing diameter breast height tree (default cm, can defined via dbh_unit). NULL (default), function tries identify dbh data. height character length 1 name variable inv_source containing height tree (default m,   can defined via heigh_unit). NULL (default), function tries identify height data. id character length 1 name variable inv_source containing unique tree ID. NULL (default), function tries identify ID data. possible, trees assigned unique number. IDs coerced character. dbh_unit character length 1. Unit diameter measurements (one \"cm\", \"m\" \"mm\". defaults \"cm\"). height_unit character length 1. Unit diameter measurements (one \"m\", \"cm\" \"mm\". defaults \"m\"). verbose logical length 1. information progress printed? Defaults TRUE. names_as_is logical length 1. TRUE, NULL characters excepted column names x, y, dbh, height id, column names internally substituted. Defaults FALSE, normally right choice interactive use (TRUE needed use within functions). ... additional arguments passed data.table::fread()","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read forest inventory data — read_inv","text":"object class c(\"forest_inv\", \"data.frame\") x y coordinates tree, unique tree identifier (id) tree diameter breast height (dbh, cm) tree height (height, m) available.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read forest inventory data — read_inv","text":"Function reading validating forest inventory data. Supports formats readable data.table::fread(). provided tabular data without explicitly specified variable names, function default takes columns named \"X\" \"Y\" (\"x\" \"y\") tree coordinates, looks columns named \"height\", \"height_m\" \"h\" well \"dbh\", \"diameter\",\"diam\", \"d\" (capitalization) size-related variables. tree ids taken columns named \"id\", \"tree_id\", \"treeID\" \"tree.id\" (capitalization). special characters besides \".\" \"_\" stripped column names matching. columns coordinates can identified, function fails error. ID column available, function assigns unique number tree (note make specifying custom target trees difficult). possible read datasets without dbh height, usually sensible used accessory datasets identifying target trees (e.g. target trees identified taking GPS coordinates manually field).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_inv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read forest inventory data — read_inv","text":"","code":"if (FALSE) { # \\dontrun{ # prepare inventory table for compete_inv() inv <- fread(path = \"path/to/table.csv\") #specify the units of parameters within your input inv_table <- read_inv(inv, dbh_unit = \"cm\", height_unit = \"m\") # Read inventory table directly from directory inv_table <- read_inv(inv_source = \"path/to/table.csv\", dbh_unit = \"cm\", height_unit = \"m\") } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Read trees and neighborhoods from point cloud data. — read_pc","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"Read validate point cloud sourced file stored disk, object inherits class data.frame, LAS object lidR package (lidR::LAS). Supported file formats .las, .laz, .ply well formats accepted data.table::fread() (.csv, .txt, others).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"","code":"read_pc(pc_source, verbose = TRUE, xlim = NULL, ylim = NULL, zlim = NULL, ...)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"pc_source object inherits class data.frame,  LAS object, character string path point cloud individual tree whole plot either .las/.laz .ply format, file format readable data.table::fread(). provided point cloud object data.frame, structure column names validated homogenized; else, function tries read point cloud specified path. verbose logical length 1. information progress printed? Defaults TRUE. xlim (optional) numeric vector defining range x coordinates. Can vector length 2 minimum maximum x value, vector arbitrary length (case base::range() used constrain x values range). can useful memory-efficient handling large point cloud objects. Defaults NULL (use full range x coordinates). ylim (optional) numeric vector defining range y coordinates. Can vector length 2 minimum maximum y value, vector arbitrary length (case base::range() used constrain y values range). can useful memory-efficient handling large point cloud objects. Defaults NULL (use full range y coordinates). zlim (optional) numeric vector defining range z coordinates. Can vector length 2 minimum maximum z value, vector arbitrary length (case base::range() used constrain z values range). can useful memory-efficient handling large point cloud objects. Defaults NULL (use full range z coordinates). ... additional arguments passed data.table::fread()","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"object class c(\"forest_pc\", \"data.table\", \"data.frame\") x, y z coordinates tree forest point cloud.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"Function reading validating point cloud data. Currently, supported file formats .las, .laz, .ply, well formats accepted data.table::fread(). formats, please load point cloud data separately enter coordinates data.frame. provided tabular data (either data.frame via path data.table::fread() readable source), function default takes columns named \"X\", \"Y\", \"Z\" \"x\", \"y\", \"z\" coordinate vectors. columns matching names available, takes first three numeric columns returns message. dataset contain three numeric columns one columns labeled x, y, z numeric, function fails error. xlim, ylim zlim arguments used internally compete_pc() filter neighborhood dataset relevant range around target tree speed calculations.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"note-support-of-las-laz-and-ply-formats","dir":"Reference","previous_headings":"","what":"Note: support of .las, .laz and .ply formats","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"'lidR' package installed able read .las/.laz files, internally processed lidR::readTLSLAS(). Analogously, point clouds .ply format, 'Rvcg' package required loaded Rvcg::vcgPlyRead().","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/read_pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read trees and neighborhoods from point cloud data. — read_pc","text":"","code":"if (FALSE) { # \\dontrun{ # Read a tree point cloud in las or laz format tree <- read_pc(pc_source = \"path/to/tree_point_cloud.las\")  # Read a tree point cloud in ply format tree <- read_pc(pc_source = \"path/to/tree_point_cloud.ply\")  # Read a tree point cloud in txt format tree <- read_pc(pc_source = \"path/to/tree_point_cloud.txt\")  # Read a tree point cloud in csv format with non-standard separators tree <- read_pc(pc_source = \"path/to/tree_point_cloud.txt\",   dec = \",\", sep = \";\")  # Read a forest point cloud in a specified range around a target tree of # known position (+- 5 m around the origin) neighborhood <- read_pc(pc_source = \"path/to/forest_point_cloud.las\",   xlim = c(-5, 5), ylim = c(-5, 5))  # Convert a point cloud already loaded as a data.frame into forest_pc format tree <- read_pc(tree_df)  } # }"},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":null,"dir":"Reference","previous_headings":"","what":"Position and Height of a Tree from Point Cloud — tree_pos","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"Compute stem base position, metroid crown projected area stem height tree","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"","code":"tree_pos(tree, z_min = 100L, h_xy = 0.3, res = 0.1, tree_name = NULL)"},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"tree tree_pc data.frame (x, y, z) tree point cloud. Coordinates metric system! z_min integer length 1 describing minimum number points needed lowermost 1 voxel depth Z layer consider part tree. Default 100. changing voxel resolution (res) default value 0.1, different settings may necessary. h_xy numeric length 1 describing height range m stem base x y positions used calculate x y coordinates stem base. Default 0.3 m. res res numeric length 1 defining resolution voxel passed VoxR::vox(). Defaults 0.1 (10 cm voxel size). tree_name character vector length 1 name tree returned output object. Defaults NULL (take name tree argument).","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"object class \"tree_pos\" containing following components: base_pos numeric vector length 3 x, y, z coordinates tree base position. crown_pos numeric vector length 3 x, y coordinates central point crown projected area z position stem base identified . height numeric length one containing tree height m. tree_name name object used \"tree\" argument, name specified user.","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"Calculates stem base position, metroid crown projected area height tree data.frame  point cloud created read_pc(). stem base, z position taken z position first voxel layer containing least z_min points point cloud (standard value 100). done avoid outlying values affecting calculated stem base height usually consistent taking median z value lowermost group points, lower sensitivity outliers. x y position stem base calculated median voxelized x y coordinates voxels first h_xy m stem base (default: first 0.3 m - values low avoided stem shape may irregular close ground). central point crown projected area computed median x y position projected area tree. height based difference z value highest voxel belonging tree z value identified stem base. calculation done voxels ensure consistency downstream analyses reduce bias caused inhomogeneous point densities different sides stem. opinion, cases makes sense calculate competition indices based central point tree crown based stem base strongly inclined trees cylinder constructed around base may contain voxels crown central tree .","code":""},{"path":"https://juliarieder.github.io/TreeCompR/reference/tree_pos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Position and Height of a Tree from Point Cloud — tree_pos","text":"","code":"if (FALSE) { # \\dontrun{ # Read the tree point cloud tree <- read_tree(path = \"path/to/tree_point_cloud.txt\") # Get the position of this tree (x, y, z) pos <- tree_pos(tree) pos } # }"}]
