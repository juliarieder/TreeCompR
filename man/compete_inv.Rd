% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compete_inventory.R
\name{compete_inv}
\alias{compete_inv}
\alias{print.compete_inv}
\title{Quantify size- and distance-dependent competition using inventory data}
\usage{
compete_inv(
  inv_source,
  target_source = "buff_edge",
  radius,
  method = c("all_methods", "CI_Hegyi", "CI_Braathe", "CI_RK1", "CI_RK2", "CI_RK3",
    "CI_RK4"),
  x = NULL,
  y = NULL,
  dbh = NULL,
  height = NULL,
  id = NULL,
  dbh_unit = c("cm", "m", "mm"),
  height_unit = c("m", "cm", "mm"),
  verbose = TRUE,
  tol = 1,
  ...
)
}
\arguments{
\item{inv_source}{either an object of class \code{target_inv}, or any object that
can be imported by \code{\link[=read_inv]{read_inv()}} (in this case, \code{x}, \code{y}, \code{id},
\code{dbh}, and/or \code{height} can be specified as in this function -- see the
corresponding documentation for details).
If provided with a \code{target_inv} object, the function ignores
\code{target_source} and overrides further arguments passed to \code{\link[=read_inv]{read_inv()}} and
\code{\link[=define_target]{define_target()}}.}

\item{target_source}{one of the following:
\enumerate{
\item a path to an any object that can be imported by \code{\link[=read_inv]{read_inv()}} (in this
case, column specifications have to be the same as in \code{inv_source} - if
this is not possible, load outside of \code{compete_inv()}).
\item a vector of class \code{"character"} containing the tree IDs identifying the
target trees in the  same format as in the \code{id} column of \code{inv},
\item a vector of class \code{logical} specifying for each row of \code{inv} whether
the corresponding tree is a target tree,
\item another object of class \code{forest_inv} containing the coordinates of the
target trees. In this case, the coordinates are matched against the
coordinates in \code{inv} and IDs may differ (useful e.g. when target trees
are defined based on GPS coordinates and matched against an airborne laser
scanning dataset).
\item a character vector of length 1 defining the method by which the target
trees should be determined. Allowed are \code{"buff_edge"} for excluding all
trees that are at least one search radius from the forest edge,
\code{"exclude_edge"} for only excluding edge trees or \code{"all_trees"} for
including all trees of the dataset (which is hardly ever a good idea
unless all trees in the entire forest are in the dataset). The standard is
\code{"buff_edge"}. See \code{\link[=define_target]{define_target()}} for details.
}}

\item{radius}{numeric of length 1. Search radius (in m) around the target
tree. All neighboring trees within this radius are classified as
competitors.}

\item{method}{character string assigning the method for quantifying
competition. dbh-distance-dependent methods are \code{"CI_Hegyi"}, \code{"CI_RK1"},
and \code{"CI_RK2"}. Height-distance-dependent methods are \code{"CI_Braathe"},
\code{"CI_RK3"}, and \code{"CI_RK4"}. \code{"all_methods"} can be specified to compute
all the indices that can be calculated with the available data.}

\item{x}{character of length 1 or name of the variable in \code{inv_source}
containing the x coordinates of the tree in m. If \code{NULL} (default),
the function tries to identify the x coordinate from the data.}

\item{y}{character of length 1 or name of the variable in \code{inv_source}
containing the y coordinates of the tree in meters. If \code{NULL} (default),
the function tries to identify the y coordinate from the data.}

\item{dbh}{character of length 1 or name of the variable in \code{inv_source}
containing the diameter at breast height of the tree (by default in cm, but
can be defined via \code{dbh_unit}). If \code{NULL} (default), the function tries to
identify the dbh from the data.}

\item{height}{character of length 1 or name of the variable in \code{inv_source}
containing the height of the tree (by default in m, but   can be defined
via \code{heigh_unit}). If \code{NULL} (default), the function tries to identify the
height from the data.}

\item{id}{character of length 1 or name of the variable in \code{inv_source}
containing a unique tree ID. If \code{NULL} (default), the function tries to
identify the ID from the data. If this is not possible, the trees are
assigned a unique number. All IDs are coerced to character.}

\item{dbh_unit}{character of length 1. Unit for the diameter measurements
(one of "cm", "m" or "mm". defaults to "cm").}

\item{height_unit}{character of length 1. Unit for the diameter measurements
(one of "m", "cm" or "mm". defaults to "m").}

\item{verbose}{logical of length 1. Should information about progress be
printed? Defaults to TRUE.}

\item{tol}{numeric of length 1. Tolerance for the match with the tree
coordinates. If coordinates are measured in the field with GPS, but
\code{inv_source} contains x and y coordinates from a larger number of trees
obtained by segmentation, this is the tolerance for the matching the
forest inventory against the target tree positions. If no forest tree is
within the tolerance to a target tree, no competition indices will be
calculated for this tree and the function will return a warning.
\code{tol} defaults to 1 m, but should be chosen depending on the measurement
accuracy of the GPS coordinates.}

\item{...}{additional arguments passed on to \code{\link[data.table:fread]{data.table::fread()}}.}
}
\value{
object of class\code{compete_inv}: a modified data.table with the
position and size of the designated target tree(s) and one or more
competition indices depending on chosen method(s).
}
\description{
\code{compete_inv()} computes one or several distance-height- or
distance-dbh-dependent competition indices based on forest inventory data.
}
\details{
\code{compete_inv()} calculates one or several distance-dependent tree
competition indices based on forest inventory data. These can be obtained
either with classical forest inventory methods, or be derived from LiDAR
point clouds (see below).

Inventory data can be either loaded from source, imported from an object
inheriting from class \code{data.frame} (i.e., data.frames, tibbles,
data.table objects etc.) or a \code{forest_inv} type object created with
\code{\link[=read_inv]{read_inv()}}. \code{compete_inv()} takes the same arguments for reading
inventory data and has the same flexibility as \code{\link[=read_inv]{read_inv()}}.

To compute competition indices for trees from an inventory dataset, it is
necessary to decide on the target trees for the analysis. While it is also
possible to calculate competition indices for all trees in the inventory,
this is almost never a good idea because unless the dataset covers all
trees in the entire forest, there will be intense edge effects for the
trees at the edge of the spatial extent of the dataset.
\code{compete_inv()} allows to define target trees in a number of different ways
based on the function \code{\link[=define_target]{define_target()}} that is called internally.
\subsection{Available competition indices}{

The competition indices are computed according to the following
equations, where \eqn{d_i} and \eqn{h_i} are the dbh and height of neighbor
tree \eqn{i}, \eqn{d} and \eqn{h} are dbh and height of the target tree,
and \eqn{dist_i} is the distance from neighbor tree \eqn{i} to the target
tree.

\emph{Diameter-based competition indices}
\itemize{
\item CI_Hegyi introduced by Hegyi (1974): \cr
\eqn{CI_{Hegyi} = \sum_{i=1}^{n} d_{i} / (d \cdot dist_{i})}
\item CI_RK1 according to CI1 Rouvinen & Kuuluvainen (1997):\cr
\eqn{CI_{RK1} = \sum_{i=1}^{n} \mathrm{arctan}(d_{i} / dist_{i})}
\item CI_RK2 according to CI3 in Rouvinen & Kuuluvainen (1997): \cr
\eqn{CI_{RK2} =\sum_{i=1}^{n} (d_{i} / d) \cdot \mathrm{arctan}(d_{i}
   / dist_{i})}
}

\emph{Height-based competition indices}
\itemize{
\item CI_Braathe according to Braathe (1980): \cr
\eqn{CI_{Braathe} = \sum_{i=1}^{n} h_{i} / (h \cdot dist_{i})}
\item CI_RK3 according to CI5 in Rouvinen & Kuuluvainen (1997): \cr
\eqn{CI_{RK3} = \sum_{i=1}^{n} \mathrm{arctan}(h_{i} / dist_{i})}
for all trees with \eqn{h_{i} > h}
\item CI_RK4 based on CI3 in Rouvinen & Kuuluvainen (1997) and
Contreras et al. (2011): \cr
\eqn{CI_{RK4} = \sum_{i=1}^{n} (h_{i} / h) \cdot
   \mathrm{arctan}(h_{i} / dist_{i})}
}

As all these indices are distance-weighted sums of the relative size of all
competitor trees within the search radius compared to the target tree (or a
sum of transformations thereof), they are very sensitive to the choice of
the search radius. It is not generally possible to meaningfully compare
competition indices computed with different search radii. Over which
distance competitors affect the growth of the central tree is certainly
specific and likely also depends on the average size of trees of the same
species as the target tree and how far its roots spread under the local
conditions. Lorimer (1983) recommends to use 3.5 times the mean crown radius
of the target trees, but it is likely that there is no single value that
works well under all conditions, and possible that the same values of
competition indices calculated with the same radius have different meanings
for different species.
}

\subsection{Tree Segmentation}{

Various approaches can be used to segment (airborne) laser scanning point
clouds into single trees and to obtain inventory data based it. Existing R
packages for this are for example:
\itemize{
\item \code{TreeLS} package for automated segmentation of terrestrial/mobile laser
scans
\item \code{lidR} package with different options to segment the point cloud or a
Canopy Height Model (CHM)
\item \code{itcLiDARallo()} from the package \code{itcSegment}
}

Be careful with low resolution/low density point clouds, as
oversegmentation of trees is usually an issue!

For examples of workflows to obtain inventory dator from airborne
laser scanning data or terrestrial/mobile laser scanning data, see
\href{https://juliarieder.github.io/TreeCompR/articles/ALS_inventory.html}{ALS workflow}
and \href{https://juliarieder.github.io/TreeCompR/articles/TLS_inventory.html}{TLS workflow},
respectively.
}

\subsection{Literature}{
\itemize{
\item Hegyi, F., 1974. A simulation model for managing jackpine stands. In:
Fries, J. (Ed.), Proceedings of IUFRO meeting S4.01.04 on Growth models
for tree and stand simulation, Royal College of Forestry, Stockholm.
\item Braathe, P., 1980. Height increment of young single trees in relation to
height and distance of neighboring trees. Mitt. Forstl. VersAnst. 130,
43–48.
\item Rouvinen, S., Kuuluvainen, T., 1997. Structure and asymmetry of tree
crowns in relation to local competition in a natural mature Scot pine
forest. Can. J. For. Res. 27, 890–902.
\item Contreras, M.A., Affleck, D. & Chung, W., 2011. Evaluating tree
competition indices as predictors of basal area increment in western
Montana forests. Forest Ecology and Management, 262(11): 1939-1949.
\item Lorimer, C.G., 1983. Tests of age-independent competition indices for
individual trees in natural hardwood stands. For. Ecol. Manage. 6,
343–360.
}
}
}
\examples{
\dontrun{
# Quantify the Hegyi index for specified target trees with search radius 10m
CI <- compete_inv("path/to/invtable.csv",
  "path/to/target_trees.csv", radius = 10, method = "CI_Hegyi")
# Quantify the Braathe index for specified target trees with search radius
#10m and adjust
CI <- compete_inv("path/to/invtable.csv",
  "path/to/target_trees.csv", radius = 10, method = "CI_Braathe")
# Specify the units of dbh or height of your input data
CI <- compete_inv("path/to/invtable.csv",
  "path/to/target_trees.csv", radius = 10, method = "CI_Hegyi",
  dbh_unit = "m", height_unit = "m")
# Quantify all available indices for all trees within the plot that are one
#search radius away from plot edge
CI <- compete_inv("path/to/invtable.csv", target_source = "buff_edge",
        radius = 12, method = "all_methods")
}
}
\seealso{
\code{\link[=read_inv]{read_inv()}} to read forest inventory data,
\code{\link[=define_target]{define_target()}} for designating target trees,
\code{\link[=plot_target]{plot_target()}} to plot target tree positions in \code{target_inv} and
\code{compete_inv} objects.
}
