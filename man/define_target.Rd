% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/define_target.R
\name{define_target}
\alias{define_target}
\alias{print.target_inv}
\title{Define target trees in forest inventory data}
\usage{
define_target(
  inv,
  target_source = "buff_edge",
  radius = 10,
  tol = 1,
  verbose = TRUE
)
}
\arguments{
\item{inv}{object of class \code{forest_inv} as created with \code{\link[=read_inv]{read_inv()}}.}

\item{target_source}{one of the following:
\enumerate{
\item a vector of class \code{"character"} containing the tree IDs identifying the
target trees in the  same format as in the \code{id} column of \code{inv}.
\item a vector of class \code{logical} specifying for each row of \code{inv} whether
the corresponding tree is a target tree.
\item another object of class \code{forest_inv} containing the coordinates of the
target trees. In this case, the coordinates are matched against the
coordinates in \code{inv} and IDs may differ (useful e.g. when target trees
are defined based on GPS coordinates and matched against an airborne laser
scanning dataset). In this case, the extent of \code{inv} will be cropped to
the extent of \code{forest_inv} \eqn{\pm} \code{radius + tol} to reduce
computational load.
\item a character vector of length 1 defining the method by which the target
trees should be determined. Allowed are \code{"buff_edge"} for excluding all
trees that are at least one search radius from the forest edge,
\code{"exclude_edge"} for only excluding edge trees or \code{"all_trees"} for
including all trees of the dataset (which is hardly ever a good idea unless
all trees in the entire forest are in the dataset). The standard is
\code{"buff_edge"}. See below for details.
}}

\item{radius}{numeric of length 1, Search radius (in m) around target tree
wherein all neighboring trees are classified as competitors. Only used if
\code{target_source} is \code{"buff_edge"}, \code{"exclude_edge"} or of type \code{forest_inv}.
Defaults to 10.}

\item{tol}{numeric. Only used when \code{target_source} is an inventory with a
second set of coordinates. Tolerance for the match between tree coordinates
in the forest inventory and target datasets if specified as a second set of
coordinates. If a field measurements (e.g. based on GPS) are used to
identify target trees and the full inventory is from a different data
source (e.g. ALS data), a higher tolerance value may be required to
identify the trees depending on the measurement accuracy. Values of 0 mean
exact matching. Defaults to 1 (match within a 1 m buffer).}

\item{verbose}{logical of length 1. Should information about progress be
printed? Defaults to TRUE.}
}
\value{
object of class \code{target_inv} (inherits from \code{forest_inv}): a
modified data.table with the x and y coordinates of the tree, a unique tree
identifier (\code{id}), at least one of tree diameter at breast height (\code{dbh},
in cm) and tree height (\code{height},in m) and a new logical column \code{target}
specifying whether a tree is defined as a target tree.
}
\description{
\code{define_target()} takes a \code{forest_inv} dataset and returns an updated forest
inventory with highlighted target trees for analysis with \code{compete_inv}.
Target trees can be manually specified by tree ID, imported from a different
dataset or identified automatically by excluding edge trees from their
coordinates.
}
\details{
\code{define_target()} can be used to select target trees from a
\code{forest_inv} object either by manually specifying them as a character
vector with tree IDs, as a logical vector that specifies for each tree in
the inventory whether or not it is treated as a target tree, a separate
set of (approximate) coordinates of the target trees that is matched
against the original inventory, or a character string describing how to
choose the target trees based on their spatial arrangement.

When the target is defined by a second set of coordinates, these
coordinates will then be matched against the inventory data. IDs are
ignored in this case and  matching is based only on the closest trees with
in a buffer of \code{tol} m  (the default is \code{tol = 1}: matching within 1 m).
All further size-related variables in the second set of coordinates are
ignored as well to make sure that in later steps competition indices will
be computed with data from the same data source.
When different target trees are matched to the same tree in the inventory,
or when two trees in the inventory have the same distance to a target
tree within 5 cm, the function fails with an error. If two inventory trees
are within the specified tolerance and the difference is larger, the
function proceeds with a warning.
The intended use case for determining target trees in this way is to
compute tree competition from ALS data based on GPS coordinates of single
trees in studies that are based on single tree rather than plot-level
data, which creates a need for different data sources to compute
competition.

The methods \code{target_source = "buff_edge"} and
\code{target_source = "exclude_edge"} are intended for cases where it is desired
to compute valid competition indices for as many trees as possible while
avoiding edge effects. While it is possible to designate all trees in the
dataset as target tree by setting \code{target_source = "all_trees"}, this is
not a good idea in the majority of cases: unless your dataset contains all
trees in the forest (possible for ALS-based data, but very unlikely for
data based on classical inventory methods and TLS/MLS), there will be very
extreme edge effects at the outer edge of the extent of the covered trees
resulting in strongly underestimated competition for edge trees.
\code{target_source = "buff_edge"} excludes all trees who are less than one
search radius (\code{radius}) away from the plot border (approximated by a
concave hull based on \code{\link[concaveman:concaveman]{concaveman::concaveman()}}) and hence guarantees to
only include trees that can obtain valid competition index values for that
search radius. \code{target_source = "exclude_edge"} only removes the edge trees
and hence is less restrictive, but more prone to edge effects.

Do not use \code{target_source = "all_trees"} unless you know exactly what you
are doing!
}
\examples{
\dontrun{
# read inventory
inv <- read_inv("path/to/invtable.csv")
#or just validate your already loaded inventory data
#e.g.extracted from lidR package
inv <- read_inv(inventory, height = Z, height_unit = "m")
# or from itcSegment (itcLiDARallo)
inv <- read_inv(inventory, height = Height_m, height_unit = "m")
# target trees defined by a buffer around the plot edges
target <- define_target(inv, target_source = "buff_edge", radius = 10)
#or if your trees are definitely at a forest edge
#(and not just at the edge of your dataset) you can include all trees
target <- define_target(inv, target_source = "all_trees", radius = 10)
}

}
\seealso{
\code{\link[=read_inv]{read_inv()}} to read forest inventory data,
\code{\link[=compete_inv]{compete_inv()}} for computing tree competition from inventory data,
\code{\link[=plot_target]{plot_target()}} to plot target tree positions in \code{target_inv} and
\code{compete_inv} objects.
}
