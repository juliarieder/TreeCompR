% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/define_target.R
\name{define_target}
\alias{define_target}
\alias{print.target_inv}
\title{Define target trees in forest inventory data}
\usage{
define_target(inv, target_source, radius = 10, tol = 1, verbose = TRUE)
}
\arguments{
\item{inv}{object of class \code{forest_inv} as created with \code{\link[=read_inv]{read_inv()}}.}

\item{target_source}{one of the following:
\enumerate{
\item a vector of class \code{"character"} containing the tree IDs identifying the
target trees in the  same format as in the \code{id} column of \code{inv}.
\item a vector of class \code{logical} specifying for each row of \code{inv} whether
the corresponding tree is a target tree.
\item another object of class \code{forest_inv} containing the coordinates of the
target trees. In this case, the coordinates are matched against the
coordinates in \code{inv} and IDs may differ (useful e.g. when target trees
are defined based on GPS coordinates and matched against an airborne laser
scanning dataset). In this case, the extent of \code{inv} will be cropped to
the extent of \code{forest_inv} \eqn{\pm} \code{radius + tol} to reduce
computational load.
\item a character vector of length 1 defining the method by which the target
trees should be determined. Allowed are \code{"buff_edge"} for excluding all
trees that are at least one search radius from the forest edge,
\code{"exclude_edge"} for only excluding edge trees or \code{"all"} for including
all trees of the dataset (which is hardly ever a good idea unless all
trees in the entire forest are in the dataset). The standard is
\code{"buff_edge"}. See below for details.
}}

\item{radius}{numeric of length 1, Search radius (in m) around target tree
wherein all neighboring trees are classified as competitors. Only used if
\code{target_source} is \code{"buff_edge"}, \code{"exclude_edge"} or of type \code{forest_inv}.
Defaults to 10.}

\item{tol}{numeric. Tolerance for the match between tree coordinates in the
forest inventory and target datasets if specified as a second set of
coordinates. If a field measurements (e.g. based on GPS) are used to
identify target trees and the full inventory is from a different data
source (e.g. ALS data), a higher tolerance value may be required to
identify the trees depending on the measurement accuracy. Values of 0 mean
exact matching.}

\item{verbose}{logical of length 1. Should information about progress be
printed? Defaults to TRUE.}
}
\value{
object of \code{c("target_inv", "forest_inv", "data.frame")} with x and y
coordinates of the tree, a unique tree identifier (\code{id}), at least one
of tree diameter at breast height (\code{dbh}, in cm) and tree height (\code{height},
in m) and a new logical column \code{target} specifying whether a tree is
considered a target tree.
}
\description{
\code{define_target()} takes a \code{forest_inv} dataset and returns an updated forest
inventory with highlighted target trees for analysis with \code{compete_inv}.
Target trees can be manually specified by tree ID, imported from a different
dataset or identified automatically by excluding edge trees from their
coordinates.
}
\details{
The input data can either be taken directly from field measurements or
derived beforehand from LiDAR point clouds.

Various approaches can be used to segment airborne laser scanning point
clouds into single trees and to obtain inventory data based it. Existing R
packages for this are for example:
\itemize{
\item lidR package with different options to segment the point cloud or a Canopy
Height Model (CHM)
\item itcLiDARallo within the package itcSegment
}

Be careful with low resolution/low density point clouds, as oversegmentation
of trees is usually an issue!
}
\examples{
\dontrun{
# red inventory
inv <- read_inv("path/to/invtable.csv")
# target trees defined by a buffer around the plot edges
target <- define_target(inv, target_source = "buff_edge", radius = 10)
}

}
